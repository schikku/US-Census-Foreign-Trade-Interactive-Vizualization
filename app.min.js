(function e(t, n, r) { function s(o, u) { if (!n[o]) { if (!t[o]) { var a = typeof require == "function" && require; if (!u && a) return a(o, !0); if (i) return i(o, !0); var f = new Error("Cannot find module '" + o + "'"); throw f.code = "MODULE_NOT_FOUND", f } var l = n[o] = { exports: {} }; t[o][0].call(l.exports, function (e) { var n = t[o][1][e]; return s(n ? n : e) }, l, l.exports, e, t, n, r) } return n[o].exports } var i = typeof require == "function" && require; for (var o = 0; o < r.length; o++) s(r[o]); return s })({ 1: [function (require, module, exports) { module.exports = { all: { ABW: { filename: "ABW.geojson", countryName: "Aruba" }, AFG: { filename: "AFG.geojson", countryName: "Afghanistan" }, AGO: { filename: "AGO.geojson", countryName: "Angola" }, AIA: { filename: "AIA.geojson", countryName: "Anguilla" }, ALB: { filename: "ALB.geojson", countryName: "Albania" }, ALA: { filename: "ALA.geojson", countryName: "Aland" }, AND: { filename: "AND.geojson", countryName: "Andorra" }, ARE: { filename: "ARE.geojson", countryName: "United Arab Emirates" }, ARG: { filename: "ARG.geojson", countryName: "Argentina" }, ARM: { filename: "ARM.geojson", countryName: "Armenia" }, ASM: { filename: "ASM.geojson", countryName: "American Samoa" }, ATA: { filename: "ATA.geojson", countryName: "Antarctica" }, ashmoreandcartieris: { filename: "ashmoreandcartieris.geojson", countryName: "Ashmore and Cartier Is." }, ATF: { filename: "ATF.geojson", countryName: "Fr. S. Antarctic Lands" }, ATG: { filename: "ATG.geojson", countryName: "Antigua and Barb." }, AUS: { filename: "AUS.geojson", countryName: "Australia" }, AUT: { filename: "AUT.geojson", countryName: "Austria" }, AZE: { filename: "AZE.geojson", countryName: "Azerbaijan" }, BDI: { filename: "BDI.geojson", countryName: "Burundi" }, BEL: { filename: "BEL.geojson", countryName: "Belgium" }, BEN: { filename: "BEN.geojson", countryName: "Benin" }, BFA: { filename: "BFA.geojson", countryName: "Burkina Faso" }, BGD: { filename: "BGD.geojson", countryName: "Bangladesh" }, BGR: { filename: "BGR.geojson", countryName: "Bulgaria" }, BHR: { filename: "BHR.geojson", countryName: "Bahrain" }, BHS: { filename: "BHS.geojson", countryName: "Bahamas" }, BIH: { filename: "BIH.geojson", countryName: "Bosnia and Herz." }, bajonuevobankpetrelis: { filename: "bajonuevobankpetrelis.geojson", countryName: "Bajo Nuevo Bank (Petrel Is.)" }, BLM: { filename: "BLM.geojson", countryName: "St-Barthélemy" }, BLR: { filename: "BLR.geojson", countryName: "Belarus" }, BLZ: { filename: "BLZ.geojson", countryName: "Belize" }, BMU: { filename: "BMU.geojson", countryName: "Bermuda" }, BOL: { filename: "BOL.geojson", countryName: "Bolivia" }, BRA: { filename: "BRA.geojson", countryName: "Brazil" }, BRB: { filename: "BRB.geojson", countryName: "Barbados" }, BRN: { filename: "BRN.geojson", countryName: "Brunei" }, BTN: { filename: "BTN.geojson", countryName: "Bhutan" }, BWA: { filename: "BWA.geojson", countryName: "Botswana" }, CAF: { filename: "CAF.geojson", countryName: "Central African Rep." }, CAN: { filename: "CAN.geojson", countryName: "Canada" }, CHE: { filename: "CHE.geojson", countryName: "Switzerland" }, CHL: { filename: "CHL.geojson", countryName: "Chile" }, CHN: { filename: "CHN.geojson", countryName: "China" }, CIV: { filename: "CIV.geojson", countryName: "Côte d'Ivoire" }, clippertoni: { filename: "clippertoni.geojson", countryName: "Clipperton I." }, CMR: { filename: "CMR.geojson", countryName: "Cameroon" }, cyprusunbufferzone: { filename: "cyprusunbufferzone.geojson", countryName: "Cyprus U.N. Buffer Zone" }, COD: { filename: "COD.geojson", countryName: "Dem. Rep. Congo" }, COG: { filename: "COG.geojson", countryName: "Congo" }, COK: { filename: "COK.geojson", countryName: "Cook Is." }, COL: { filename: "COL.geojson", countryName: "Colombia" }, COM: { filename: "COM.geojson", countryName: "Comoros" }, CPV: { filename: "CPV.geojson", countryName: "Cape Verde" }, CRI: { filename: "CRI.geojson", countryName: "Costa Rica" }, coralseais: { filename: "coralseais.geojson", countryName: "Coral Sea Is." }, CUB: { filename: "CUB.geojson", countryName: "Cuba" }, CUW: { filename: "CUW.geojson", countryName: "Curaçao" }, CYM: { filename: "CYM.geojson", countryName: "Cayman Is." }, CYN: { filename: "CYN.geojson", countryName: "N. Cyprus" }, CYP: { filename: "CYP.geojson", countryName: "Cyprus" }, CZE: { filename: "CZE.geojson", countryName: "Czech Rep." }, DEU: { filename: "DEU.geojson", countryName: "Germany" }, DJI: { filename: "DJI.geojson", countryName: "Djibouti" }, DMA: { filename: "DMA.geojson", countryName: "Dominica" }, DNK: { filename: "DNK.geojson", countryName: "Denmark" }, DOM: { filename: "DOM.geojson", countryName: "Dominican Rep." }, DZA: { filename: "DZA.geojson", countryName: "Algeria" }, ECU: { filename: "ECU.geojson", countryName: "Ecuador" }, EGY: { filename: "EGY.geojson", countryName: "Egypt" }, ERI: { filename: "ERI.geojson", countryName: "Eritrea" }, dhekelia: { filename: "dhekelia.geojson", countryName: "Dhekelia" }, ESP: { filename: "ESP.geojson", countryName: "Spain" }, EST: { filename: "EST.geojson", countryName: "Estonia" }, ETH: { filename: "ETH.geojson", countryName: "Ethiopia" }, FIN: { filename: "FIN.geojson", countryName: "Finland" }, FJI: { filename: "FJI.geojson", countryName: "Fiji" }, FLK: { filename: "FLK.geojson", countryName: "Falkland Is." }, FRA: { filename: "FRA.geojson", countryName: "France" }, FRO: { filename: "FRO.geojson", countryName: "Faeroe Is." }, FSM: { filename: "FSM.geojson", countryName: "Micronesia" }, GAB: { filename: "GAB.geojson", countryName: "Gabon" }, GBR: { filename: "GBR.geojson", countryName: "United Kingdom" }, GEO: { filename: "GEO.geojson", countryName: "Georgia" }, GGY: { filename: "GGY.geojson", countryName: "Guernsey" }, GHA: { filename: "GHA.geojson", countryName: "Ghana" }, GIB: { filename: "GIB.geojson", countryName: "Gibraltar" }, GIN: { filename: "GIN.geojson", countryName: "Guinea" }, GMB: { filename: "GMB.geojson", countryName: "Gambia" }, GNB: { filename: "GNB.geojson", countryName: "Guinea-Bissau" }, GNQ: { filename: "GNQ.geojson", countryName: "Eq. Guinea" }, GRC: { filename: "GRC.geojson", countryName: "Greece" }, GRD: { filename: "GRD.geojson", countryName: "Grenada" }, GRL: { filename: "GRL.geojson", countryName: "Greenland" }, GTM: { filename: "GTM.geojson", countryName: "Guatemala" }, GUM: { filename: "GUM.geojson", countryName: "Guam" }, GUY: { filename: "GUY.geojson", countryName: "Guyana" }, HKG: { filename: "HKG.geojson", countryName: "Hong Kong" }, HMD: { filename: "HMD.geojson", countryName: "Heard I. and McDonald Is." }, HND: { filename: "HND.geojson", countryName: "Honduras" }, HRV: { filename: "HRV.geojson", countryName: "Croatia" }, HTI: { filename: "HTI.geojson", countryName: "Haiti" }, HUN: { filename: "HUN.geojson", countryName: "Hungary" }, IDN: { filename: "IDN.geojson", countryName: "Indonesia" }, IMN: { filename: "IMN.geojson", countryName: "Isle of Man" }, IND: { filename: "IND.geojson", countryName: "India" }, indianoceanter: { filename: "indianoceanter.geojson", countryName: "Indian Ocean Ter." }, IOT: { filename: "IOT.geojson", countryName: "Br. Indian Ocean Ter." }, IRL: { filename: "IRL.geojson", countryName: "Ireland" }, IRN: { filename: "IRN.geojson", countryName: "Iran" }, IRQ: { filename: "IRQ.geojson", countryName: "Iraq" }, ISL: { filename: "ISL.geojson", countryName: "Iceland" }, ISR: { filename: "ISR.geojson", countryName: "Israel" }, ITA: { filename: "ITA.geojson", countryName: "Italy" }, JAM: { filename: "JAM.geojson", countryName: "Jamaica" }, JEY: { filename: "JEY.geojson", countryName: "Jersey" }, JOR: { filename: "JOR.geojson", countryName: "Jordan" }, JPN: { filename: "JPN.geojson", countryName: "Japan" }, baikonur: { filename: "baikonur.geojson", countryName: "Baikonur" }, siachenglacier: { filename: "siachenglacier.geojson", countryName: "Siachen Glacier" }, KAZ: { filename: "KAZ.geojson", countryName: "Kazakhstan" }, KEN: { filename: "KEN.geojson", countryName: "Kenya" }, KGZ: { filename: "KGZ.geojson", countryName: "Kyrgyzstan" }, KHM: { filename: "KHM.geojson", countryName: "Cambodia" }, KIR: { filename: "KIR.geojson", countryName: "Kiribati" }, KNA: { filename: "KNA.geojson", countryName: "St. Kitts and Nevis" }, KOR: { filename: "KOR.geojson", countryName: "Korea" }, KOS: { filename: "KOS.geojson", countryName: "Kosovo" }, KWT: { filename: "KWT.geojson", countryName: "Kuwait" }, LAO: { filename: "LAO.geojson", countryName: "Lao PDR" }, LBN: { filename: "LBN.geojson", countryName: "Lebanon" }, LBR: { filename: "LBR.geojson", countryName: "Liberia" }, LBY: { filename: "LBY.geojson", countryName: "Libya" }, LCA: { filename: "LCA.geojson", countryName: "Saint Lucia" }, LIE: { filename: "LIE.geojson", countryName: "Liechtenstein" }, LKA: { filename: "LKA.geojson", countryName: "Sri Lanka" }, LSO: { filename: "LSO.geojson", countryName: "Lesotho" }, LTU: { filename: "LTU.geojson", countryName: "Lithuania" }, LUX: { filename: "LUX.geojson", countryName: "Luxembourg" }, LVA: { filename: "LVA.geojson", countryName: "Latvia" }, MAC: { filename: "MAC.geojson", countryName: "Macao" }, MAF: { filename: "MAF.geojson", countryName: "St-Martin" }, MAR: { filename: "MAR.geojson", countryName: "Morocco" }, MCO: { filename: "MCO.geojson", countryName: "Monaco" }, MDA: { filename: "MDA.geojson", countryName: "Moldova" }, MDG: { filename: "MDG.geojson", countryName: "Madagascar" }, MDV: { filename: "MDV.geojson", countryName: "Maldives" }, MEX: { filename: "MEX.geojson", countryName: "Mexico" }, MHL: { filename: "MHL.geojson", countryName: "Marshall Is." }, MKD: { filename: "MKD.geojson", countryName: "Macedonia" }, MLI: { filename: "MLI.geojson", countryName: "Mali" }, MLT: { filename: "MLT.geojson", countryName: "Malta" }, MMR: { filename: "MMR.geojson", countryName: "Myanmar" }, MNE: { filename: "MNE.geojson", countryName: "Montenegro" }, MNG: { filename: "MNG.geojson", countryName: "Mongolia" }, MNP: { filename: "MNP.geojson", countryName: "N. Mariana Is." }, MOZ: { filename: "MOZ.geojson", countryName: "Mozambique" }, MRT: { filename: "MRT.geojson", countryName: "Mauritania" }, MSR: { filename: "MSR.geojson", countryName: "Montserrat" }, MUS: { filename: "MUS.geojson", countryName: "Mauritius" }, MWI: { filename: "MWI.geojson", countryName: "Malawi" }, MYS: { filename: "MYS.geojson", countryName: "Malaysia" }, NAM: { filename: "NAM.geojson", countryName: "Namibia" }, NCL: { filename: "NCL.geojson", countryName: "New Caledonia" }, NER: { filename: "NER.geojson", countryName: "Niger" }, NFK: { filename: "NFK.geojson", countryName: "Norfolk Island" }, NGA: { filename: "NGA.geojson", countryName: "Nigeria" }, NIC: { filename: "NIC.geojson", countryName: "Nicaragua" }, NIU: { filename: "NIU.geojson", countryName: "Niue" }, NLD: { filename: "NLD.geojson", countryName: "Netherlands" }, NOR: { filename: "NOR.geojson", countryName: "Norway" }, NPL: { filename: "NPL.geojson", countryName: "Nepal" }, NRU: { filename: "NRU.geojson", countryName: "Nauru" }, NZL: { filename: "NZL.geojson", countryName: "New Zealand" }, OMN: { filename: "OMN.geojson", countryName: "Oman" }, PAK: { filename: "PAK.geojson", countryName: "Pakistan" }, PAN: { filename: "PAN.geojson", countryName: "Panama" }, PCN: { filename: "PCN.geojson", countryName: "Pitcairn Is." }, PER: { filename: "PER.geojson", countryName: "Peru" }, spratlyis: { filename: "spratlyis.geojson", countryName: "Spratly Is." }, PHL: { filename: "PHL.geojson", countryName: "Philippines" }, PLW: { filename: "PLW.geojson", countryName: "Palau" }, PNG: { filename: "PNG.geojson", countryName: "Papua New Guinea" }, POL: { filename: "POL.geojson", countryName: "Poland" }, PRI: { filename: "PRI.geojson", countryName: "Puerto Rico" }, PRK: { filename: "PRK.geojson", countryName: "Dem. Rep. Korea" }, PRT: { filename: "PRT.geojson", countryName: "Portugal" }, PRY: { filename: "PRY.geojson", countryName: "Paraguay" }, PSE: { filename: "PSE.geojson", countryName: "Palestine" }, PYF: { filename: "PYF.geojson", countryName: "Fr. Polynesia" }, QAT: { filename: "QAT.geojson", countryName: "Qatar" }, ROU: { filename: "ROU.geojson", countryName: "Romania" }, RUS: { filename: "RUS.geojson", countryName: "Russia" }, RWA: { filename: "RWA.geojson", countryName: "Rwanda" }, ESH: { filename: "ESH.geojson", countryName: "W. Sahara" }, SAU: { filename: "SAU.geojson", countryName: "Saudi Arabia" }, scarboroughreef: { filename: "scarboroughreef.geojson", countryName: "Scarborough Reef" }, SDN: { filename: "SDN.geojson", countryName: "Sudan" }, SSD: { filename: "SSD.geojson", countryName: "S. Sudan" }, SEN: { filename: "SEN.geojson", countryName: "Senegal" }, serranillabank: { filename: "serranillabank.geojson", countryName: "Serranilla Bank" }, SGP: { filename: "SGP.geojson", countryName: "Singapore" }, SGS: { filename: "SGS.geojson", countryName: "S. Geo. and S. Sandw. Is." }, SHN: { filename: "SHN.geojson", countryName: "Saint Helena" }, SLB: { filename: "SLB.geojson", countryName: "Solomon Is." }, SLE: { filename: "SLE.geojson", countryName: "Sierra Leone" }, SLV: { filename: "SLV.geojson", countryName: "El Salvador" }, SMR: { filename: "SMR.geojson", countryName: "San Marino" }, somaliland: { filename: "somaliland.geojson", countryName: "Somaliland" }, SOM: { filename: "SOM.geojson", countryName: "Somalia" }, SPM: { filename: "SPM.geojson", countryName: "St. Pierre and Miquelon" }, SRB: { filename: "SRB.geojson", countryName: "Serbia" }, STP: { filename: "STP.geojson", countryName: "São Tomé and Principe" }, SUR: { filename: "SUR.geojson", countryName: "Suriname" }, SVK: { filename: "SVK.geojson", countryName: "Slovakia" }, SVN: { filename: "SVN.geojson", countryName: "Slovenia" }, SWE: { filename: "SWE.geojson", countryName: "Sweden" }, SWZ: { filename: "SWZ.geojson", countryName: "Swaziland" }, SXM: { filename: "SXM.geojson", countryName: "Sint Maarten" }, SYC: { filename: "SYC.geojson", countryName: "Seychelles" }, SYR: { filename: "SYR.geojson", countryName: "Syria" }, TCA: { filename: "TCA.geojson", countryName: "Turks and Caicos Is." }, TCD: { filename: "TCD.geojson", countryName: "Chad" }, TGO: { filename: "TGO.geojson", countryName: "Togo" }, THA: { filename: "THA.geojson", countryName: "Thailand" }, TJK: { filename: "TJK.geojson", countryName: "Tajikistan" }, TKM: { filename: "TKM.geojson", countryName: "Turkmenistan" }, TLS: { filename: "TLS.geojson", countryName: "Timor-Leste" }, TON: { filename: "TON.geojson", countryName: "Tonga" }, TTO: { filename: "TTO.geojson", countryName: "Trinidad and Tobago" }, TUN: { filename: "TUN.geojson", countryName: "Tunisia" }, TUR: { filename: "TUR.geojson", countryName: "Turkey" }, TUV: { filename: "TUV.geojson", countryName: "Tuvalu" }, TWN: { filename: "TWN.geojson", countryName: "Taiwan" }, TZA: { filename: "TZA.geojson", countryName: "Tanzania" }, UGA: { filename: "UGA.geojson", countryName: "Uganda" }, UKR: { filename: "UKR.geojson", countryName: "Ukraine" }, UMI: { filename: "UMI.geojson", countryName: "U.S. Minor Outlying Is." }, URY: { filename: "URY.geojson", countryName: "Uruguay" }, USA: { filename: "USA.geojson", countryName: "United States" }, usnbguantanamobay: { filename: "usnbguantanamobay.geojson", countryName: "USNB Guantanamo Bay" }, UZB: { filename: "UZB.geojson", countryName: "Uzbekistan" }, VAT: { filename: "VAT.geojson", countryName: "Vatican" }, VCT: { filename: "VCT.geojson", countryName: "St. Vin. and Gren." }, VEN: { filename: "VEN.geojson", countryName: "Venezuela" }, VGB: { filename: "VGB.geojson", countryName: "British Virgin Is." }, VIR: { filename: "VIR.geojson", countryName: "U.S. Virgin Is." }, VNM: { filename: "VNM.geojson", countryName: "Vietnam" }, VUT: { filename: "VUT.geojson", countryName: "Vanuatu" }, WLF: { filename: "WLF.geojson", countryName: "Wallis and Futuna Is." }, akrotiri: { filename: "akrotiri.geojson", countryName: "Akrotiri" }, WSM: { filename: "WSM.geojson", countryName: "Samoa" }, YEM: { filename: "YEM.geojson", countryName: "Yemen" }, ZAF: { filename: "ZAF.geojson", countryName: "South Africa" }, ZMB: { filename: "ZMB.geojson", countryName: "Zambia" }, ZWE: { filename: "ZWE.geojson", countryName: "Zimbabwe" } }, "North America": { Aruba: "ABW.geojson", Anguilla: "AIA.geojson", "Antigua and Barb.": "ATG.geojson", Bahamas: "BHS.geojson", "Bajo Nuevo Bank (Petrel Is.)": "bajonuevobankpetrelis.geojson", "St-Barthélemy": "BLM.geojson", Belize: "BLZ.geojson", Bermuda: "BMU.geojson", Barbados: "BRB.geojson", Canada: "CAN.geojson", "Costa Rica": "CRI.geojson", Cuba: "CUB.geojson", "Curaçao": "CUW.geojson", "Cayman Is.": "CYM.geojson", Dominica: "DMA.geojson", "Dominican Rep.": "DOM.geojson", Grenada: "GRD.geojson", Greenland: "GRL.geojson", Guatemala: "GTM.geojson", Honduras: "HND.geojson", Haiti: "HTI.geojson", Jamaica: "JAM.geojson", "St. Kitts and Nevis": "KNA.geojson", "Saint Lucia": "LCA.geojson", "St-Martin": "MAF.geojson", Mexico: "MEX.geojson", Montserrat: "MSR.geojson", Nicaragua: "NIC.geojson", Panama: "PAN.geojson", "Puerto Rico": "PRI.geojson", "Serranilla Bank": "serranillabank.geojson", "El Salvador": "SLV.geojson", "St. Pierre and Miquelon": "SPM.geojson", "Sint Maarten": "SXM.geojson", "Turks and Caicos Is.": "TCA.geojson", "Trinidad and Tobago": "TTO.geojson", "U.S. Minor Outlying Is.": "UMI.geojson", "United States": "USA.geojson", "USNB Guantanamo Bay": "usnbguantanamobay.geojson", "St. Vin. and Gren.": "VCT.geojson", "British Virgin Is.": "VGB.geojson", "U.S. Virgin Is.": "VIR.geojson" }, Asia: { Afghanistan: "AFG.geojson", "United Arab Emirates": "ARE.geojson", Armenia: "ARM.geojson", Azerbaijan: "AZE.geojson", Bangladesh: "BGD.geojson", Bahrain: "BHR.geojson", Brunei: "BRN.geojson", Bhutan: "BTN.geojson", China: "CHN.geojson", "Cyprus U.N. Buffer Zone": "cyprusunbufferzone.geojson", "N. Cyprus": "CYN.geojson", Cyprus: "CYP.geojson", Dhekelia: "dhekelia.geojson", Georgia: "GEO.geojson", "Hong Kong": "HKG.geojson", Indonesia: "IDN.geojson", India: "IND.geojson", "Indian Ocean Ter.": "indianoceanter.geojson", Iran: "IRN.geojson", Iraq: "IRQ.geojson", Israel: "ISR.geojson", Jordan: "JOR.geojson", Japan: "JPN.geojson", Baikonur: "baikonur.geojson", "Siachen Glacier": "siachenglacier.geojson", Kazakhstan: "KAZ.geojson", Kyrgyzstan: "KGZ.geojson", Cambodia: "KHM.geojson", Korea: "KOR.geojson", Kuwait: "KWT.geojson", "Lao PDR": "LAO.geojson", Lebanon: "LBN.geojson", "Sri Lanka": "LKA.geojson", Macao: "MAC.geojson", Myanmar: "MMR.geojson", Mongolia: "MNG.geojson", Malaysia: "MYS.geojson", Nepal: "NPL.geojson", Oman: "OMN.geojson", Pakistan: "PAK.geojson", "Spratly Is.": "spratlyis.geojson", Philippines: "PHL.geojson", "Dem. Rep. Korea": "PRK.geojson", Palestine: "PSE.geojson", Qatar: "QAT.geojson", "Saudi Arabia": "SAU.geojson", "Scarborough Reef": "scarboroughreef.geojson", Singapore: "SGP.geojson", Syria: "SYR.geojson", Thailand: "THA.geojson", Tajikistan: "TJK.geojson", Turkmenistan: "TKM.geojson", "Timor-Leste": "TLS.geojson", Turkey: "TUR.geojson", Taiwan: "TWN.geojson", Uzbekistan: "UZB.geojson", Vietnam: "VNM.geojson", Akrotiri: "akrotiri.geojson", Yemen: "YEM.geojson" }, Africa: { Angola: "AGO.geojson", Burundi: "BDI.geojson", Benin: "BEN.geojson", "Burkina Faso": "BFA.geojson", Botswana: "BWA.geojson", "Central African Rep.": "CAF.geojson", "Côte d'Ivoire": "CIV.geojson", Cameroon: "CMR.geojson", "Dem. Rep. Congo": "COD.geojson", Congo: "COG.geojson", Comoros: "COM.geojson", "Cape Verde": "CPV.geojson", Djibouti: "DJI.geojson", Algeria: "DZA.geojson", Egypt: "EGY.geojson", Eritrea: "ERI.geojson", Ethiopia: "ETH.geojson", Gabon: "GAB.geojson", Ghana: "GHA.geojson", Guinea: "GIN.geojson", Gambia: "GMB.geojson", "Guinea-Bissau": "GNB.geojson", "Eq. Guinea": "GNQ.geojson", Kenya: "KEN.geojson", Liberia: "LBR.geojson", Libya: "LBY.geojson", Lesotho: "LSO.geojson", Morocco: "MAR.geojson", Madagascar: "MDG.geojson", Mali: "MLI.geojson", Mozambique: "MOZ.geojson", Mauritania: "MRT.geojson", Malawi: "MWI.geojson", Namibia: "NAM.geojson", Niger: "NER.geojson", Nigeria: "NGA.geojson", Rwanda: "RWA.geojson", "W. Sahara": "ESH.geojson", Sudan: "SDN.geojson", "S. Sudan": "SSD.geojson", Senegal: "SEN.geojson", "Sierra Leone": "SLE.geojson", Somaliland: "somaliland.geojson", Somalia: "SOM.geojson", "São Tomé and Principe": "STP.geojson", Swaziland: "SWZ.geojson", Chad: "TCD.geojson", Togo: "TGO.geojson", Tunisia: "TUN.geojson", Tanzania: "TZA.geojson", Uganda: "UGA.geojson", "South Africa": "ZAF.geojson", Zambia: "ZMB.geojson", Zimbabwe: "ZWE.geojson" }, Europe: { Albania: "ALB.geojson", Aland: "ALA.geojson", Andorra: "AND.geojson", Austria: "AUT.geojson", Belgium: "BEL.geojson", Bulgaria: "BGR.geojson", "Bosnia and Herz.": "BIH.geojson", Belarus: "BLR.geojson", Switzerland: "CHE.geojson", "Czech Rep.": "CZE.geojson", Germany: "DEU.geojson", Denmark: "DNK.geojson", Spain: "ESP.geojson", Estonia: "EST.geojson", Finland: "FIN.geojson", France: "FRA.geojson", "Faeroe Is.": "FRO.geojson", "United Kingdom": "GBR.geojson", Guernsey: "GGY.geojson", Gibraltar: "GIB.geojson", Greece: "GRC.geojson", Croatia: "HRV.geojson", Hungary: "HUN.geojson", "Isle of Man": "IMN.geojson", Ireland: "IRL.geojson", Iceland: "ISL.geojson", Italy: "ITA.geojson", Jersey: "JEY.geojson", Kosovo: "KOS.geojson", Liechtenstein: "LIE.geojson", Lithuania: "LTU.geojson", Luxembourg: "LUX.geojson", Latvia: "LVA.geojson", Monaco: "MCO.geojson", Moldova: "MDA.geojson", Macedonia: "MKD.geojson", Malta: "MLT.geojson", Montenegro: "MNE.geojson", Netherlands: "NLD.geojson", Norway: "NOR.geojson", Poland: "POL.geojson", Portugal: "PRT.geojson", Romania: "ROU.geojson", Russia: "RUS.geojson", "San Marino": "SMR.geojson", Serbia: "SRB.geojson", Slovakia: "SVK.geojson", Slovenia: "SVN.geojson", Sweden: "SWE.geojson", Ukraine: "UKR.geojson", Vatican: "VAT.geojson" }, "South America": { Argentina: "ARG.geojson", Bolivia: "BOL.geojson", Brazil: "BRA.geojson", Chile: "CHL.geojson", Colombia: "COL.geojson", Ecuador: "ECU.geojson", "Falkland Is.": "FLK.geojson", Guyana: "GUY.geojson", Peru: "PER.geojson", Paraguay: "PRY.geojson", Suriname: "SUR.geojson", Uruguay: "URY.geojson", Venezuela: "VEN.geojson" }, Oceania: { "American Samoa": "ASM.geojson", "Ashmore and Cartier Is.": "ashmoreandcartieris.geojson", Australia: "AUS.geojson", "Cook Is.": "COK.geojson", "Coral Sea Is.": "coralseais.geojson", Fiji: "FJI.geojson", Micronesia: "FSM.geojson", Guam: "GUM.geojson", Kiribati: "KIR.geojson", "Marshall Is.": "MHL.geojson", "N. Mariana Is.": "MNP.geojson", "New Caledonia": "NCL.geojson", "Norfolk Island": "NFK.geojson", Niue: "NIU.geojson", Nauru: "NRU.geojson", "New Zealand": "NZL.geojson", "Pitcairn Is.": "PCN.geojson", Palau: "PLW.geojson", "Papua New Guinea": "PNG.geojson", "Fr. Polynesia": "PYF.geojson", "Solomon Is.": "SLB.geojson", Tonga: "TON.geojson", Tuvalu: "TUV.geojson", Vanuatu: "VUT.geojson", "Wallis and Futuna Is.": "WLF.geojson", Samoa: "WSM.geojson" }, Antarctica: { Antarctica: "ATA.geojson" }, "Seven seas (open ocean)": { "Fr. S. Antarctic Lands": "ATF.geojson", "Clipperton I.": "clippertoni.geojson", "Heard I. and McDonald Is.": "HMD.geojson", "Br. Indian Ocean Ter.": "IOT.geojson", Maldives: "MDV.geojson", Mauritius: "MUS.geojson", "S. Geo. and S. Sandw. Is.": "SGS.geojson", "Saint Helena": "SHN.geojson", Seychelles: "SYC.geojson" } } }, {}], 2: [function (require, module, exports) { (function () { var continents = require("../../countries/10m/index"); var leafletCountries = {}; var allowedCountries = {}; var async = require("async"); var filesaver = require("filesaver.js"); var base64 = require("js-base64").Base64; var DEFAULT_FILL = "#fff"; var SELECTED_FILL = "#aaffaa"; var ALERT_TEXT = '<div class="alert alert-danger"><strong>Hold up, cowboy!</strong> This browser is <em>way too old</em> to be using the Internet.' + '<br><br>This web app won\'t work until you <a class="btn btn-danger" href="http://browsehappy.com/">Update your Browser</a></div>'; var $progressBar = $('<div class="panel panel-default panel-progress"><div class="panel-heading">Loading…</div><div class="panel-body"><div class="progress progress-striped active"><div class="progress-bar"  role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" style="width: 0"></div></div></div></div>'); var maps = {}; var analytics = function () { (function (i, s, o, g, r, a, m) { i["GoogleAnalyticsObject"] = r; i[r] = i[r] || function () { (i[r].q = i[r].q || []).push(arguments) }, i[r].l = 1 * new Date; a = s.createElement(o), m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m) })(window, document, "script", "//www.google-analytics.com/analytics.js", "ga"); ga("create", "UA-2547771-21", "kyd.com.au"); ga("send", "pageview") }; if (!window.$ || !window.JSON || !window.Blob || !window.console || !window.console.log) { window.onload = function () { document.getElementById("oldie-fallback").innerHTML = ALERT_TEXT }; analytics(); return } console.log("%c              •••• •••••                                  \n" + "            ••••••••••••••           ••                     \n" + "           •• •• ••••••••     ••           ••               \n" + "         •    • •••••••••     ••            •               \n" + "           ••     •••••••             •    ••••    •        \n" + "       •• ••••     •••••               • ••••••••           \n" + " •••  • •••  ••••  •••••       ••      ••••••••••••••••     \n" + " •••••••••••••  •• •••        ••••••••••••••••••••••••••••• \n" + "•••••••••••••   •   •        •••••••••••••••••••••••••••••  \n" + "  •  ••••••• • •••                          •••••••   •     \n" + "      •••••••• ••••   CUSTOM GEOJSON MAPS!  ••••••••        \n" + "       •••••••••• •                         ••••••••        \n" + "       •••••••••          •••••••••••••••••••••••  •        \n" + "        •••••••           •••• •  •••••••••••••• •          \n" + "         •••             ••••••••••••  •••••••••            \n" + "             •           ••••••••••••   ••  ••              \n" + "               •••        •• •••••••     •  •  •            \n" + "               ••••••         •••••          ••   •         \n" + "               •••••••        •••••               ••        \n" + "                •••••         •••• •           ••••••       \n" + "                ••••           ••              ••••••       \n" + "                •••                                ••       \n" + "               ••                                           \n" + "               ••                                           \n", "background: #fff; color: #68f", "\nPlease don't be alarmed at HTTP errors in here. Some countries " + "aren't available at lower resolutions, and this is a blunt" + "tool. :)\n\n"); var progress = function (action, valuenow, max) { var $bw = $(".build-widget"); var $ele = $(".build-widget").parent(); var $progress = $ele.find(".panel-progress"); if (action === false) { $progress.remove(); $bw.show(); return } if ($progress.length == 0) { $progress = $progressBar.clone(); $ele.append($progress); $bw.hide() } $progress.find(".progress-bar").attr("aria-valuemax", max).attr("aria-valuenow", valuenow).width(valuenow / max * 100 + "%"); $progress.find(".panel-heading").html(action) }; var ctxFillColor = function (country) { return allowedCountries[country] ? SELECTED_FILL : DEFAULT_FILL }; var setCountry = function (country, val) { allowedCountries[country] = val; if (leafletCountries[country]) { leafletCountries[country].setStyle({ fillColor: ctxFillColor(country) }) } var count = 0; for (var i in allowedCountries) { if (allowedCountries[i]) { count++ } } if (count == 0) { $("button.build").attr("disabled", "disabled") } else { $("button.build").removeAttr("disabled") } }; $(document).ready(function () { $("#setup").hide(); progress("Loading initial map&hellip;", 100, 100); $.getJSON("countries/110m/all.geojson", function (json) { progress(false); initMap("map", json, { clickable: true, style: { fillColor: "#fff", fillOpacity: 1, fill: true, color: "#eee", weight: 1, opacity: 1 }, pointToLayer: function (feature, latlng) { return L.circleMarker(latlng).bindLabel(feature.properties.name, { noHide: true }) }, onEachFeature: function (feature, layer) { var name = feature.properties.name; leafletCountries[name] = layer; layer.on("click", function () { setCountry(name, !allowedCountries[name]) }); layer.on("mouseover", function () { layer.setStyle({ fillColor: "#ffffaa" }) }); layer.on("mouseout", function () { layer.setStyle({ fillColor: ctxFillColor(name) }) }) } }) }); analytics(); function initMap(target, data, opts) { if (maps[target]) { maps[target].remove() } maps[target] = L.map(target, { minZoom: 1, maxZoom: 10, scrollWheelZoom: false }).setView([0, 0], 2); L.geoJson(data, opts).addTo(maps[target]); return map } $(".build").click(function () { var resolution = $("[name=resolution]:checked").val(); var files = []; for (var country in allowedCountries) { for (var continent in continents) { if (allowedCountries[country] && continents[continent][country]) { files.push("countries/" + resolution + "/" + continents[continent][country]) } } } var features = []; var downloadsComplete = 0; function progressText() { return "Downloaded " + (downloadsComplete + 1) + " of " + files.length + " countries&hellip;" } var action = function (item, callback) { $.ajax({ dataType: "json", url: item, success: function (data) { features = features.concat(data); progress(progressText(), ++downloadsComplete, files.length); callback() }, error: function (e) { progress(progressText(), ++downloadsComplete, files.length); callback() } }) }; var complete = function (err) { var geojson = { type: "FeatureCollection", features: features }; var jsonString = JSON.stringify(geojson); var geoJsonBlob = new Blob([jsonString], { type: "application/json;charset=utf-8" }); filesaver.saveAs(geoJsonBlob, "custom.geo.json"); $(".results .kb").text(Math.round(jsonString.length / 1024)); $("#setup").show(); initMap("preview-map", geojson, { clickable: false, style: { color: "#fff", weight: 1, opacity: 1, fill: true, fillColor: "#fff", fillOpacity: 1 } }); $("html, body").animate({ scrollTop: $("#setup").offset().top + "px" }); progress(false) }; progress(progressText(), 0, files.length); async.eachLimit(files, 10, action, complete) }); $(".continents input").change(function () { var val = $(this).is(":checked"); var continent = $(this).val(); for (var country in continents[continent]) { setCountry(country, val) } }) }) })() }, { "../../countries/10m/index": 1, async: 3, "filesaver.js": 6, "js-base64": 9 }], 3: [function (require, module, exports) { (function (process, global) { (function (global, factory) { typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global.async = global.async || {}) })(this, function (exports) { "use strict"; function slice(arrayLike, start) { start = start | 0; var newLen = Math.max(arrayLike.length - start, 0); var newArr = Array(newLen); for (var idx = 0; idx < newLen; idx++) { newArr[idx] = arrayLike[start + idx] } return newArr } var initialParams = function (fn) { return function () { var args = slice(arguments); var callback = args.pop(); fn.call(this, args, callback) } }; function isObject(value) { var type = typeof value; return value != null && (type == "object" || type == "function") } var hasSetImmediate = typeof setImmediate === "function" && setImmediate; var hasNextTick = typeof process === "object" && typeof process.nextTick === "function"; function fallback(fn) { setTimeout(fn, 0) } function wrap(defer) { return function (fn) { var args = slice(arguments, 1); defer(function () { fn.apply(null, args) }) } } var _defer; if (hasSetImmediate) { _defer = setImmediate } else if (hasNextTick) { _defer = process.nextTick } else { _defer = fallback } var setImmediate$1 = wrap(_defer); function asyncify(func) { return initialParams(function (args, callback) { var result; try { result = func.apply(this, args) } catch (e) { return callback(e) } if (isObject(result) && typeof result.then === "function") { result.then(function (value) { invokeCallback(callback, null, value) }, function (err) { invokeCallback(callback, err.message ? err : new Error(err)) }) } else { callback(null, result) } }) } function invokeCallback(callback, error, value) { try { callback(error, value) } catch (e) { setImmediate$1(rethrow, e) } } function rethrow(error) { throw error } var supportsSymbol = typeof Symbol === "function"; function isAsync(fn) { return supportsSymbol && fn[Symbol.toStringTag] === "AsyncFunction" } function wrapAsync(asyncFn) { return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn } function applyEach$1(eachfn) { return function (fns) { var args = slice(arguments, 1); var go = initialParams(function (args, callback) { var that = this; return eachfn(fns, function (fn, cb) { wrapAsync(fn).apply(that, args.concat(cb)) }, callback) }); if (args.length) { return go.apply(this, args) } else { return go } } } var freeGlobal = typeof global == "object" && global && global.Object === Object && global; var freeSelf = typeof self == "object" && self && self.Object === Object && self; var root = freeGlobal || freeSelf || Function("return this")(); var Symbol$1 = root.Symbol; var objectProto = Object.prototype; var hasOwnProperty = objectProto.hasOwnProperty; var nativeObjectToString = objectProto.toString; var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined; function getRawTag(value) { var isOwn = hasOwnProperty.call(value, symToStringTag$1), tag = value[symToStringTag$1]; try { value[symToStringTag$1] = undefined; var unmasked = true } catch (e) { } var result = nativeObjectToString.call(value); if (unmasked) { if (isOwn) { value[symToStringTag$1] = tag } else { delete value[symToStringTag$1] } } return result } var objectProto$1 = Object.prototype; var nativeObjectToString$1 = objectProto$1.toString; function objectToString(value) { return nativeObjectToString$1.call(value) } var nullTag = "[object Null]"; var undefinedTag = "[object Undefined]"; var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined; function baseGetTag(value) { if (value == null) { return value === undefined ? undefinedTag : nullTag } value = Object(value); return symToStringTag && symToStringTag in value ? getRawTag(value) : objectToString(value) } var asyncTag = "[object AsyncFunction]"; var funcTag = "[object Function]"; var genTag = "[object GeneratorFunction]"; var proxyTag = "[object Proxy]"; function isFunction(value) { if (!isObject(value)) { return false } var tag = baseGetTag(value); return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag } var MAX_SAFE_INTEGER = 9007199254740991; function isLength(value) { return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER } function isArrayLike(value) { return value != null && isLength(value.length) && !isFunction(value) } var breakLoop = {}; function noop() { } function once(fn) { return function () { if (fn === null) return; var callFn = fn; fn = null; callFn.apply(this, arguments) } } var iteratorSymbol = typeof Symbol === "function" && Symbol.iterator; var getIterator = function (coll) { return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]() }; function baseTimes(n, iteratee) { var index = -1, result = Array(n); while (++index < n) { result[index] = iteratee(index) } return result } function isObjectLike(value) { return value != null && typeof value == "object" } var argsTag = "[object Arguments]"; function baseIsArguments(value) { return isObjectLike(value) && baseGetTag(value) == argsTag } var objectProto$3 = Object.prototype; var hasOwnProperty$2 = objectProto$3.hasOwnProperty; var propertyIsEnumerable = objectProto$3.propertyIsEnumerable; var isArguments = baseIsArguments(function () { return arguments }()) ? baseIsArguments : function (value) { return isObjectLike(value) && hasOwnProperty$2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee") }; var isArray = Array.isArray; function stubFalse() { return false } var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports; var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module; var moduleExports = freeModule && freeModule.exports === freeExports; var Buffer = moduleExports ? root.Buffer : undefined; var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined; var isBuffer = nativeIsBuffer || stubFalse; var MAX_SAFE_INTEGER$1 = 9007199254740991; var reIsUint = /^(?:0|[1-9]\d*)$/; function isIndex(value, length) { length = length == null ? MAX_SAFE_INTEGER$1 : length; return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length) } var argsTag$1 = "[object Arguments]"; var arrayTag = "[object Array]"; var boolTag = "[object Boolean]"; var dateTag = "[object Date]"; var errorTag = "[object Error]"; var funcTag$1 = "[object Function]"; var mapTag = "[object Map]"; var numberTag = "[object Number]"; var objectTag = "[object Object]"; var regexpTag = "[object RegExp]"; var setTag = "[object Set]"; var stringTag = "[object String]"; var weakMapTag = "[object WeakMap]"; var arrayBufferTag = "[object ArrayBuffer]"; var dataViewTag = "[object DataView]"; var float32Tag = "[object Float32Array]"; var float64Tag = "[object Float64Array]"; var int8Tag = "[object Int8Array]"; var int16Tag = "[object Int16Array]"; var int32Tag = "[object Int32Array]"; var uint8Tag = "[object Uint8Array]"; var uint8ClampedTag = "[object Uint8ClampedArray]"; var uint16Tag = "[object Uint16Array]"; var uint32Tag = "[object Uint32Array]"; var typedArrayTags = {}; typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true; typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false; function baseIsTypedArray(value) { return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)] } function baseUnary(func) { return function (value) { return func(value) } } var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports; var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module; var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1; var freeProcess = moduleExports$1 && freeGlobal.process; var nodeUtil = function () { try { return freeProcess && freeProcess.binding("util") } catch (e) { } }(); var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray; var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray; var objectProto$2 = Object.prototype; var hasOwnProperty$1 = objectProto$2.hasOwnProperty; function arrayLikeKeys(value, inherited) { var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length; for (var key in value) { if ((inherited || hasOwnProperty$1.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) { result.push(key) } } return result } var objectProto$5 = Object.prototype; function isPrototype(value) { var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$5; return value === proto } function overArg(func, transform) { return function (arg) { return func(transform(arg)) } } var nativeKeys = overArg(Object.keys, Object); var objectProto$4 = Object.prototype; var hasOwnProperty$3 = objectProto$4.hasOwnProperty; function baseKeys(object) { if (!isPrototype(object)) { return nativeKeys(object) } var result = []; for (var key in Object(object)) { if (hasOwnProperty$3.call(object, key) && key != "constructor") { result.push(key) } } return result } function keys(object) { return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object) } function createArrayIterator(coll) { var i = -1; var len = coll.length; return function next() { return ++i < len ? { value: coll[i], key: i } : null } } function createES2015Iterator(iterator) { var i = -1; return function next() { var item = iterator.next(); if (item.done) return null; i++; return { value: item.value, key: i } } } function createObjectIterator(obj) { var okeys = keys(obj); var i = -1; var len = okeys.length; return function next() { var key = okeys[++i]; return i < len ? { value: obj[key], key: key } : null } } function iterator(coll) { if (isArrayLike(coll)) { return createArrayIterator(coll) } var iterator = getIterator(coll); return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll) } function onlyOnce(fn) { return function () { if (fn === null) throw new Error("Callback was already called."); var callFn = fn; fn = null; callFn.apply(this, arguments) } } function _eachOfLimit(limit) { return function (obj, iteratee, callback) { callback = once(callback || noop); if (limit <= 0 || !obj) { return callback(null) } var nextElem = iterator(obj); var done = false; var running = 0; function iterateeCallback(err, value) { running -= 1; if (err) { done = true; callback(err) } else if (value === breakLoop || done && running <= 0) { done = true; return callback(null) } else { replenish() } } function replenish() { while (running < limit && !done) { var elem = nextElem(); if (elem === null) { done = true; if (running <= 0) { callback(null) } return } running += 1; iteratee(elem.value, elem.key, onlyOnce(iterateeCallback)) } } replenish() } } function eachOfLimit(coll, limit, iteratee, callback) { _eachOfLimit(limit)(coll, wrapAsync(iteratee), callback) } function doLimit(fn, limit) { return function (iterable, iteratee, callback) { return fn(iterable, limit, iteratee, callback) } } function eachOfArrayLike(coll, iteratee, callback) { callback = once(callback || noop); var index = 0, completed = 0, length = coll.length; if (length === 0) { callback(null) } function iteratorCallback(err, value) { if (err) { callback(err) } else if (++completed === length || value === breakLoop) { callback(null) } } for (; index < length; index++) { iteratee(coll[index], index, onlyOnce(iteratorCallback)) } } var eachOfGeneric = doLimit(eachOfLimit, Infinity); var eachOf = function (coll, iteratee, callback) { var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric; eachOfImplementation(coll, wrapAsync(iteratee), callback) }; function doParallel(fn) { return function (obj, iteratee, callback) { return fn(eachOf, obj, wrapAsync(iteratee), callback) } } function _asyncMap(eachfn, arr, iteratee, callback) { callback = callback || noop; arr = arr || []; var results = []; var counter = 0; var _iteratee = wrapAsync(iteratee); eachfn(arr, function (value, _, callback) { var index = counter++; _iteratee(value, function (err, v) { results[index] = v; callback(err) }) }, function (err) { callback(err, results) }) } var map = doParallel(_asyncMap); var applyEach = applyEach$1(map); function doParallelLimit(fn) { return function (obj, limit, iteratee, callback) { return fn(_eachOfLimit(limit), obj, wrapAsync(iteratee), callback) } } var mapLimit = doParallelLimit(_asyncMap); var mapSeries = doLimit(mapLimit, 1); var applyEachSeries = applyEach$1(mapSeries); var apply = function (fn) { var args = slice(arguments, 1); return function () { var callArgs = slice(arguments); return fn.apply(null, args.concat(callArgs)) } }; function arrayEach(array, iteratee) { var index = -1, length = array == null ? 0 : array.length; while (++index < length) { if (iteratee(array[index], index, array) === false) { break } } return array } function createBaseFor(fromRight) { return function (object, iteratee, keysFunc) { var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length; while (length--) { var key = props[fromRight ? length : ++index]; if (iteratee(iterable[key], key, iterable) === false) { break } } return object } } var baseFor = createBaseFor(); function baseForOwn(object, iteratee) { return object && baseFor(object, iteratee, keys) } function baseFindIndex(array, predicate, fromIndex, fromRight) { var length = array.length, index = fromIndex + (fromRight ? 1 : -1); while (fromRight ? index-- : ++index < length) { if (predicate(array[index], index, array)) { return index } } return -1 } function baseIsNaN(value) { return value !== value } function strictIndexOf(array, value, fromIndex) { var index = fromIndex - 1, length = array.length; while (++index < length) { if (array[index] === value) { return index } } return -1 } function baseIndexOf(array, value, fromIndex) { return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex) } var auto = function (tasks, concurrency, callback) { if (typeof concurrency === "function") { callback = concurrency; concurrency = null } callback = once(callback || noop); var keys$$1 = keys(tasks); var numTasks = keys$$1.length; if (!numTasks) { return callback(null) } if (!concurrency) { concurrency = numTasks } var results = {}; var runningTasks = 0; var hasError = false; var listeners = Object.create(null); var readyTasks = []; var readyToCheck = []; var uncheckedDependencies = {}; baseForOwn(tasks, function (task, key) { if (!isArray(task)) { enqueueTask(key, [task]); readyToCheck.push(key); return } var dependencies = task.slice(0, task.length - 1); var remainingDependencies = dependencies.length; if (remainingDependencies === 0) { enqueueTask(key, task); readyToCheck.push(key); return } uncheckedDependencies[key] = remainingDependencies; arrayEach(dependencies, function (dependencyName) { if (!tasks[dependencyName]) { throw new Error("async.auto task `" + key + "` has a non-existent dependency `" + dependencyName + "` in " + dependencies.join(", ")) } addListener(dependencyName, function () { remainingDependencies--; if (remainingDependencies === 0) { enqueueTask(key, task) } }) }) }); checkForDeadlocks(); processQueue(); function enqueueTask(key, task) { readyTasks.push(function () { runTask(key, task) }) } function processQueue() { if (readyTasks.length === 0 && runningTasks === 0) { return callback(null, results) } while (readyTasks.length && runningTasks < concurrency) { var run = readyTasks.shift(); run() } } function addListener(taskName, fn) { var taskListeners = listeners[taskName]; if (!taskListeners) { taskListeners = listeners[taskName] = [] } taskListeners.push(fn) } function taskComplete(taskName) { var taskListeners = listeners[taskName] || []; arrayEach(taskListeners, function (fn) { fn() }); processQueue() } function runTask(key, task) { if (hasError) return; var taskCallback = onlyOnce(function (err, result) { runningTasks--; if (arguments.length > 2) { result = slice(arguments, 1) } if (err) { var safeResults = {}; baseForOwn(results, function (val, rkey) { safeResults[rkey] = val }); safeResults[key] = result; hasError = true; listeners = Object.create(null); callback(err, safeResults) } else { results[key] = result; taskComplete(key) } }); runningTasks++; var taskFn = wrapAsync(task[task.length - 1]); if (task.length > 1) { taskFn(results, taskCallback) } else { taskFn(taskCallback) } } function checkForDeadlocks() { var currentTask; var counter = 0; while (readyToCheck.length) { currentTask = readyToCheck.pop(); counter++; arrayEach(getDependents(currentTask), function (dependent) { if (--uncheckedDependencies[dependent] === 0) { readyToCheck.push(dependent) } }) } if (counter !== numTasks) { throw new Error("async.auto cannot execute tasks due to a recursive dependency") } } function getDependents(taskName) { var result = []; baseForOwn(tasks, function (task, key) { if (isArray(task) && baseIndexOf(task, taskName, 0) >= 0) { result.push(key) } }); return result } }; function arrayMap(array, iteratee) { var index = -1, length = array == null ? 0 : array.length, result = Array(length); while (++index < length) { result[index] = iteratee(array[index], index, array) } return result } var symbolTag = "[object Symbol]"; function isSymbol(value) { return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag } var INFINITY = 1 / 0; var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined; var symbolToString = symbolProto ? symbolProto.toString : undefined; function baseToString(value) { if (typeof value == "string") { return value } if (isArray(value)) { return arrayMap(value, baseToString) + "" } if (isSymbol(value)) { return symbolToString ? symbolToString.call(value) : "" } var result = value + ""; return result == "0" && 1 / value == -INFINITY ? "-0" : result } function baseSlice(array, start, end) { var index = -1, length = array.length; if (start < 0) { start = -start > length ? 0 : length + start } end = end > length ? length : end; if (end < 0) { end += length } length = start > end ? 0 : end - start >>> 0; start >>>= 0; var result = Array(length); while (++index < length) { result[index] = array[index + start] } return result } function castSlice(array, start, end) { var length = array.length; end = end === undefined ? length : end; return !start && end >= length ? array : baseSlice(array, start, end) } function charsEndIndex(strSymbols, chrSymbols) { var index = strSymbols.length; while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) { } return index } function charsStartIndex(strSymbols, chrSymbols) { var index = -1, length = strSymbols.length; while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) { } return index } function asciiToArray(string) { return string.split("") } var rsAstralRange = "\\ud800-\\udfff"; var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23"; var rsComboSymbolsRange = "\\u20d0-\\u20f0"; var rsVarRange = "\\ufe0e\\ufe0f"; var rsZWJ = "\\u200d"; var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + "]"); function hasUnicode(string) { return reHasUnicode.test(string) } var rsAstralRange$1 = "\\ud800-\\udfff"; var rsComboMarksRange$1 = "\\u0300-\\u036f\\ufe20-\\ufe23"; var rsComboSymbolsRange$1 = "\\u20d0-\\u20f0"; var rsVarRange$1 = "\\ufe0e\\ufe0f"; var rsAstral = "[" + rsAstralRange$1 + "]"; var rsCombo = "[" + rsComboMarksRange$1 + rsComboSymbolsRange$1 + "]"; var rsFitz = "\\ud83c[\\udffb-\\udfff]"; var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")"; var rsNonAstral = "[^" + rsAstralRange$1 + "]"; var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}"; var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]"; var rsZWJ$1 = "\\u200d"; var reOptMod = rsModifier + "?"; var rsOptVar = "[" + rsVarRange$1 + "]?"; var rsOptJoin = "(?:" + rsZWJ$1 + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*"; var rsSeq = rsOptVar + reOptMod + rsOptJoin; var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")"; var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g"); function unicodeToArray(string) { return string.match(reUnicode) || [] } function stringToArray(string) { return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string) } function toString(value) { return value == null ? "" : baseToString(value) } var reTrim = /^\s+|\s+$/g; function trim(string, chars, guard) { string = toString(string); if (string && (guard || chars === undefined)) { return string.replace(reTrim, "") } if (!string || !(chars = baseToString(chars))) { return string } var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1; return castSlice(strSymbols, start, end).join("") } var FN_ARGS = /^(?:async\s+)?(function)?\s*[^\(]*\(\s*([^\)]*)\)/m; var FN_ARG_SPLIT = /,/; var FN_ARG = /(=.+)?(\s*)$/; var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm; function parseParams(func) { func = func.toString().replace(STRIP_COMMENTS, ""); func = func.match(FN_ARGS)[2].replace(" ", ""); func = func ? func.split(FN_ARG_SPLIT) : []; func = func.map(function (arg) { return trim(arg.replace(FN_ARG, "")) }); return func } function autoInject(tasks, callback) { var newTasks = {}; baseForOwn(tasks, function (taskFn, key) { var params; var fnIsAsync = isAsync(taskFn); var hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0; if (isArray(taskFn)) { params = taskFn.slice(0, -1); taskFn = taskFn[taskFn.length - 1]; newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn) } else if (hasNoDeps) { newTasks[key] = taskFn } else { params = parseParams(taskFn); if (taskFn.length === 0 && !fnIsAsync && params.length === 0) { throw new Error("autoInject task functions require explicit parameters.") } if (!fnIsAsync) params.pop(); newTasks[key] = params.concat(newTask) } function newTask(results, taskCb) { var newArgs = arrayMap(params, function (name) { return results[name] }); newArgs.push(taskCb); wrapAsync(taskFn).apply(null, newArgs) } }); auto(newTasks, callback) } function DLL() { this.head = this.tail = null; this.length = 0 } function setInitial(dll, node) { dll.length = 1; dll.head = dll.tail = node } DLL.prototype.removeLink = function (node) { if (node.prev) node.prev.next = node.next; else this.head = node.next; if (node.next) node.next.prev = node.prev; else this.tail = node.prev; node.prev = node.next = null; this.length -= 1; return node }; DLL.prototype.empty = function () { while (this.head) this.shift(); return this }; DLL.prototype.insertAfter = function (node, newNode) { newNode.prev = node; newNode.next = node.next; if (node.next) node.next.prev = newNode; else this.tail = newNode; node.next = newNode; this.length += 1 }; DLL.prototype.insertBefore = function (node, newNode) { newNode.prev = node.prev; newNode.next = node; if (node.prev) node.prev.next = newNode; else this.head = newNode; node.prev = newNode; this.length += 1 }; DLL.prototype.unshift = function (node) { if (this.head) this.insertBefore(this.head, node); else setInitial(this, node) }; DLL.prototype.push = function (node) { if (this.tail) this.insertAfter(this.tail, node); else setInitial(this, node) }; DLL.prototype.shift = function () { return this.head && this.removeLink(this.head) }; DLL.prototype.pop = function () { return this.tail && this.removeLink(this.tail) }; DLL.prototype.toArray = function () { var arr = Array(this.length); var curr = this.head; for (var idx = 0; idx < this.length; idx++) { arr[idx] = curr.data; curr = curr.next } return arr }; DLL.prototype.remove = function (testFn) { var curr = this.head; while (!!curr) { var next = curr.next; if (testFn(curr)) { this.removeLink(curr) } curr = next } return this }; function queue(worker, concurrency, payload) { if (concurrency == null) { concurrency = 1 } else if (concurrency === 0) { throw new Error("Concurrency must not be zero") } var _worker = wrapAsync(worker); var numRunning = 0; var workersList = []; function _insert(data, insertAtFront, callback) { if (callback != null && typeof callback !== "function") { throw new Error("task callback must be a function") } q.started = true; if (!isArray(data)) { data = [data] } if (data.length === 0 && q.idle()) { return setImmediate$1(function () { q.drain() }) } for (var i = 0, l = data.length; i < l; i++) { var item = { data: data[i], callback: callback || noop }; if (insertAtFront) { q._tasks.unshift(item) } else { q._tasks.push(item) } } setImmediate$1(q.process) } function _next(tasks) { return function (err) { numRunning -= 1; for (var i = 0, l = tasks.length; i < l; i++) { var task = tasks[i]; var index = baseIndexOf(workersList, task, 0); if (index >= 0) { workersList.splice(index, 1) } task.callback.apply(task, arguments); if (err != null) { q.error(err, task.data) } } if (numRunning <= q.concurrency - q.buffer) { q.unsaturated() } if (q.idle()) { q.drain() } q.process() } } var isProcessing = false; var q = { _tasks: new DLL, concurrency: concurrency, payload: payload, saturated: noop, unsaturated: noop, buffer: concurrency / 4, empty: noop, drain: noop, error: noop, started: false, paused: false, push: function (data, callback) { _insert(data, false, callback) }, kill: function () { q.drain = noop; q._tasks.empty() }, unshift: function (data, callback) { _insert(data, true, callback) }, remove: function (testFn) { q._tasks.remove(testFn) }, process: function () { if (isProcessing) { return } isProcessing = true; while (!q.paused && numRunning < q.concurrency && q._tasks.length) { var tasks = [], data = []; var l = q._tasks.length; if (q.payload) l = Math.min(l, q.payload); for (var i = 0; i < l; i++) { var node = q._tasks.shift(); tasks.push(node); workersList.push(node); data.push(node.data) } numRunning += 1; if (q._tasks.length === 0) { q.empty() } if (numRunning === q.concurrency) { q.saturated() } var cb = onlyOnce(_next(tasks)); _worker(data, cb) } isProcessing = false }, length: function () { return q._tasks.length }, running: function () { return numRunning }, workersList: function () { return workersList }, idle: function () { return q._tasks.length + numRunning === 0 }, pause: function () { q.paused = true }, resume: function () { if (q.paused === false) { return } q.paused = false; setImmediate$1(q.process) } }; return q } function cargo(worker, payload) { return queue(worker, 1, payload) } var eachOfSeries = doLimit(eachOfLimit, 1); function reduce(coll, memo, iteratee, callback) { callback = once(callback || noop); var _iteratee = wrapAsync(iteratee); eachOfSeries(coll, function (x, i, callback) { _iteratee(memo, x, function (err, v) { memo = v; callback(err) }) }, function (err) { callback(err, memo) }) } function seq() { var _functions = arrayMap(arguments, wrapAsync); return function () { var args = slice(arguments); var that = this; var cb = args[args.length - 1]; if (typeof cb == "function") { args.pop() } else { cb = noop } reduce(_functions, args, function (newargs, fn, cb) { fn.apply(that, newargs.concat(function (err) { var nextargs = slice(arguments, 1); cb(err, nextargs) })) }, function (err, results) { cb.apply(that, [err].concat(results)) }) } } var compose = function () { return seq.apply(null, slice(arguments).reverse()) }; var _concat = Array.prototype.concat; var concatLimit = function (coll, limit, iteratee, callback) { callback = callback || noop; var _iteratee = wrapAsync(iteratee); mapLimit(coll, limit, function (val, callback) { _iteratee(val, function (err) { if (err) return callback(err); return callback(null, slice(arguments, 1)) }) }, function (err, mapResults) { var result = []; for (var i = 0; i < mapResults.length; i++) { if (mapResults[i]) { result = _concat.apply(result, mapResults[i]) } } return callback(err, result) }) }; var concat = doLimit(concatLimit, Infinity); var concatSeries = doLimit(concatLimit, 1); var constant = function () { var values = slice(arguments); var args = [null].concat(values); return function () { var callback = arguments[arguments.length - 1]; return callback.apply(this, args) } }; function identity(value) { return value } function _createTester(check, getResult) { return function (eachfn, arr, iteratee, cb) { cb = cb || noop; var testPassed = false; var testResult; eachfn(arr, function (value, _, callback) { iteratee(value, function (err, result) { if (err) { callback(err) } else if (check(result) && !testResult) { testPassed = true; testResult = getResult(true, value); callback(null, breakLoop) } else { callback() } }) }, function (err) { if (err) { cb(err) } else { cb(null, testPassed ? testResult : getResult(false)) } }) } } function _findGetResult(v, x) { return x } var detect = doParallel(_createTester(identity, _findGetResult)); var detectLimit = doParallelLimit(_createTester(identity, _findGetResult)); var detectSeries = doLimit(detectLimit, 1); function consoleFunc(name) { return function (fn) { var args = slice(arguments, 1); args.push(function (err) { var args = slice(arguments, 1); if (typeof console === "object") { if (err) { if (console.error) { console.error(err) } } else if (console[name]) { arrayEach(args, function (x) { console[name](x) }) } } }); wrapAsync(fn).apply(null, args) } } var dir = consoleFunc("dir"); function doDuring(fn, test, callback) { callback = onlyOnce(callback || noop); var _fn = wrapAsync(fn); var _test = wrapAsync(test); function next(err) { if (err) return callback(err); var args = slice(arguments, 1); args.push(check); _test.apply(this, args) } function check(err, truth) { if (err) return callback(err); if (!truth) return callback(null); _fn(next) } check(null, true) } function doWhilst(iteratee, test, callback) { callback = onlyOnce(callback || noop); var _iteratee = wrapAsync(iteratee); var next = function (err) { if (err) return callback(err); var args = slice(arguments, 1); if (test.apply(this, args)) return _iteratee(next); callback.apply(null, [null].concat(args)) }; _iteratee(next) } function doUntil(iteratee, test, callback) { doWhilst(iteratee, function () { return !test.apply(this, arguments) }, callback) } function during(test, fn, callback) { callback = onlyOnce(callback || noop); var _fn = wrapAsync(fn); var _test = wrapAsync(test); function next(err) { if (err) return callback(err); _test(check) } function check(err, truth) { if (err) return callback(err); if (!truth) return callback(null); _fn(next) } _test(check) } function _withoutIndex(iteratee) { return function (value, index, callback) { return iteratee(value, callback) } } function eachLimit(coll, iteratee, callback) { eachOf(coll, _withoutIndex(wrapAsync(iteratee)), callback) } function eachLimit$1(coll, limit, iteratee, callback) { _eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback) } var eachSeries = doLimit(eachLimit$1, 1); function ensureAsync(fn) { if (isAsync(fn)) return fn; return initialParams(function (args, callback) { var sync = true; args.push(function () { var innerArgs = arguments; if (sync) { setImmediate$1(function () { callback.apply(null, innerArgs) }) } else { callback.apply(null, innerArgs) } }); fn.apply(this, args); sync = false }) } function notId(v) { return !v } var every = doParallel(_createTester(notId, notId)); var everyLimit = doParallelLimit(_createTester(notId, notId)); var everySeries = doLimit(everyLimit, 1); function baseProperty(key) { return function (object) { return object == null ? undefined : object[key] } } function filterArray(eachfn, arr, iteratee, callback) { var truthValues = new Array(arr.length); eachfn(arr, function (x, index, callback) { iteratee(x, function (err, v) { truthValues[index] = !!v; callback(err) }) }, function (err) { if (err) return callback(err); var results = []; for (var i = 0; i < arr.length; i++) { if (truthValues[i]) results.push(arr[i]) } callback(null, results) }) } function filterGeneric(eachfn, coll, iteratee, callback) { var results = []; eachfn(coll, function (x, index, callback) { iteratee(x, function (err, v) { if (err) { callback(err) } else { if (v) { results.push({ index: index, value: x }) } callback() } }) }, function (err) { if (err) { callback(err) } else { callback(null, arrayMap(results.sort(function (a, b) { return a.index - b.index }), baseProperty("value"))) } }) } function _filter(eachfn, coll, iteratee, callback) { var filter = isArrayLike(coll) ? filterArray : filterGeneric; filter(eachfn, coll, wrapAsync(iteratee), callback || noop) } var filter = doParallel(_filter); var filterLimit = doParallelLimit(_filter); var filterSeries = doLimit(filterLimit, 1); function forever(fn, errback) { var done = onlyOnce(errback || noop); var task = wrapAsync(ensureAsync(fn)); function next(err) { if (err) return done(err); task(next) } next() } var groupByLimit = function (coll, limit, iteratee, callback) { callback = callback || noop; var _iteratee = wrapAsync(iteratee); mapLimit(coll, limit, function (val, callback) { _iteratee(val, function (err, key) { if (err) return callback(err); return callback(null, { key: key, val: val }) }) }, function (err, mapResults) { var result = {}; var hasOwnProperty = Object.prototype.hasOwnProperty; for (var i = 0; i < mapResults.length; i++) { if (mapResults[i]) { var key = mapResults[i].key; var val = mapResults[i].val; if (hasOwnProperty.call(result, key)) { result[key].push(val) } else { result[key] = [val] } } } return callback(err, result) }) }; var groupBy = doLimit(groupByLimit, Infinity); var groupBySeries = doLimit(groupByLimit, 1); var log = consoleFunc("log"); function mapValuesLimit(obj, limit, iteratee, callback) { callback = once(callback || noop); var newObj = {}; var _iteratee = wrapAsync(iteratee); eachOfLimit(obj, limit, function (val, key, next) { _iteratee(val, key, function (err, result) { if (err) return next(err); newObj[key] = result; next() }) }, function (err) { callback(err, newObj) }) } var mapValues = doLimit(mapValuesLimit, Infinity); var mapValuesSeries = doLimit(mapValuesLimit, 1); function has(obj, key) { return key in obj } function memoize(fn, hasher) { var memo = Object.create(null); var queues = Object.create(null); hasher = hasher || identity; var _fn = wrapAsync(fn); var memoized = initialParams(function memoized(args, callback) { var key = hasher.apply(null, args); if (has(memo, key)) { setImmediate$1(function () { callback.apply(null, memo[key]) }) } else if (has(queues, key)) { queues[key].push(callback) } else { queues[key] = [callback]; _fn.apply(null, args.concat(function () { var args = slice(arguments); memo[key] = args; var q = queues[key]; delete queues[key]; for (var i = 0, l = q.length; i < l; i++) { q[i].apply(null, args) } })) } }); memoized.memo = memo; memoized.unmemoized = fn; return memoized } var _defer$1; if (hasNextTick) { _defer$1 = process.nextTick } else if (hasSetImmediate) { _defer$1 = setImmediate } else { _defer$1 = fallback } var nextTick = wrap(_defer$1); function _parallel(eachfn, tasks, callback) { callback = callback || noop; var results = isArrayLike(tasks) ? [] : {}; eachfn(tasks, function (task, key, callback) { wrapAsync(task)(function (err, result) { if (arguments.length > 2) { result = slice(arguments, 1) } results[key] = result; callback(err) }) }, function (err) { callback(err, results) }) } function parallelLimit(tasks, callback) { _parallel(eachOf, tasks, callback) } function parallelLimit$1(tasks, limit, callback) { _parallel(_eachOfLimit(limit), tasks, callback) } var queue$1 = function (worker, concurrency) { var _worker = wrapAsync(worker); return queue(function (items, cb) { _worker(items[0], cb) }, concurrency, 1) }; var priorityQueue = function (worker, concurrency) { var q = queue$1(worker, concurrency); q.push = function (data, priority, callback) { if (callback == null) callback = noop; if (typeof callback !== "function") { throw new Error("task callback must be a function") } q.started = true; if (!isArray(data)) { data = [data] } if (data.length === 0) { return setImmediate$1(function () { q.drain() }) } priority = priority || 0; var nextNode = q._tasks.head; while (nextNode && priority >= nextNode.priority) { nextNode = nextNode.next } for (var i = 0, l = data.length; i < l; i++) { var item = { data: data[i], priority: priority, callback: callback }; if (nextNode) { q._tasks.insertBefore(nextNode, item) } else { q._tasks.push(item) } } setImmediate$1(q.process) }; delete q.unshift; return q }; function race(tasks, callback) { callback = once(callback || noop); if (!isArray(tasks)) return callback(new TypeError("First argument to race must be an array of functions")); if (!tasks.length) return callback(); for (var i = 0, l = tasks.length; i < l; i++) { wrapAsync(tasks[i])(callback) } } function reduceRight(array, memo, iteratee, callback) { var reversed = slice(array).reverse(); reduce(reversed, memo, iteratee, callback) } function reflect(fn) { var _fn = wrapAsync(fn); return initialParams(function reflectOn(args, reflectCallback) { args.push(function callback(error, cbArg) { if (error) { reflectCallback(null, { error: error }) } else { var value; if (arguments.length <= 2) { value = cbArg } else { value = slice(arguments, 1) } reflectCallback(null, { value: value }) } }); return _fn.apply(this, args) }) } function reject$1(eachfn, arr, iteratee, callback) { _filter(eachfn, arr, function (value, cb) { iteratee(value, function (err, v) { cb(err, !v) }) }, callback) } var reject = doParallel(reject$1); function reflectAll(tasks) { var results; if (isArray(tasks)) { results = arrayMap(tasks, reflect) } else { results = {}; baseForOwn(tasks, function (task, key) { results[key] = reflect.call(this, task) }) } return results } var rejectLimit = doParallelLimit(reject$1); var rejectSeries = doLimit(rejectLimit, 1); function constant$1(value) { return function () { return value } } function retry(opts, task, callback) { var DEFAULT_TIMES = 5; var DEFAULT_INTERVAL = 0; var options = { times: DEFAULT_TIMES, intervalFunc: constant$1(DEFAULT_INTERVAL) }; function parseTimes(acc, t) { if (typeof t === "object") { acc.times = +t.times || DEFAULT_TIMES; acc.intervalFunc = typeof t.interval === "function" ? t.interval : constant$1(+t.interval || DEFAULT_INTERVAL); acc.errorFilter = t.errorFilter } else if (typeof t === "number" || typeof t === "string") { acc.times = +t || DEFAULT_TIMES } else { throw new Error("Invalid arguments for async.retry") } } if (arguments.length < 3 && typeof opts === "function") { callback = task || noop; task = opts } else { parseTimes(options, opts); callback = callback || noop } if (typeof task !== "function") { throw new Error("Invalid arguments for async.retry") } var _task = wrapAsync(task); var attempt = 1; function retryAttempt() { _task(function (err) { if (err && attempt++ < options.times && (typeof options.errorFilter != "function" || options.errorFilter(err))) { setTimeout(retryAttempt, options.intervalFunc(attempt)) } else { callback.apply(null, arguments) } }) } retryAttempt() } var retryable = function (opts, task) { if (!task) { task = opts; opts = null } var _task = wrapAsync(task); return initialParams(function (args, callback) { function taskFn(cb) { _task.apply(null, args.concat(cb)) } if (opts) retry(opts, taskFn, callback); else retry(taskFn, callback) }) }; function series(tasks, callback) { _parallel(eachOfSeries, tasks, callback) } var some = doParallel(_createTester(Boolean, identity)); var someLimit = doParallelLimit(_createTester(Boolean, identity)); var someSeries = doLimit(someLimit, 1); function sortBy(coll, iteratee, callback) { var _iteratee = wrapAsync(iteratee); map(coll, function (x, callback) { _iteratee(x, function (err, criteria) { if (err) return callback(err); callback(null, { value: x, criteria: criteria }) }) }, function (err, results) { if (err) return callback(err); callback(null, arrayMap(results.sort(comparator), baseProperty("value"))) }); function comparator(left, right) { var a = left.criteria, b = right.criteria; return a < b ? -1 : a > b ? 1 : 0 } } function timeout(asyncFn, milliseconds, info) { var fn = wrapAsync(asyncFn); return initialParams(function (args, callback) { var timedOut = false; var timer; function timeoutCallback() { var name = asyncFn.name || "anonymous"; var error = new Error('Callback function "' + name + '" timed out.'); error.code = "ETIMEDOUT"; if (info) { error.info = info } timedOut = true; callback(error) } args.push(function () { if (!timedOut) { callback.apply(null, arguments); clearTimeout(timer) } }); timer = setTimeout(timeoutCallback, milliseconds); fn.apply(null, args) }) } var nativeCeil = Math.ceil; var nativeMax = Math.max; function baseRange(start, end, step, fromRight) { var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length); while (length--) { result[fromRight ? length : ++index] = start; start += step } return result } function timeLimit(count, limit, iteratee, callback) { var _iteratee = wrapAsync(iteratee); mapLimit(baseRange(0, count, 1), limit, _iteratee, callback) } var times = doLimit(timeLimit, Infinity); var timesSeries = doLimit(timeLimit, 1); function transform(coll, accumulator, iteratee, callback) { if (arguments.length <= 3) { callback = iteratee; iteratee = accumulator; accumulator = isArray(coll) ? [] : {} } callback = once(callback || noop); var _iteratee = wrapAsync(iteratee); eachOf(coll, function (v, k, cb) { _iteratee(accumulator, v, k, cb) }, function (err) { callback(err, accumulator) }) } function tryEach(tasks, callback) { var error = null; var result; callback = callback || noop; eachSeries(tasks, function (task, callback) { wrapAsync(task)(function (err, res) { if (arguments.length > 2) { result = slice(arguments, 1) } else { result = res } error = err; callback(!err) }) }, function () { callback(error, result) }) } function unmemoize(fn) { return function () { return (fn.unmemoized || fn).apply(null, arguments) } } function whilst(test, iteratee, callback) { callback = onlyOnce(callback || noop); var _iteratee = wrapAsync(iteratee); if (!test()) return callback(null); var next = function (err) { if (err) return callback(err); if (test()) return _iteratee(next); var args = slice(arguments, 1); callback.apply(null, [null].concat(args)) }; _iteratee(next) } function until(test, iteratee, callback) { whilst(function () { return !test.apply(this, arguments) }, iteratee, callback) } var waterfall = function (tasks, callback) { callback = once(callback || noop); if (!isArray(tasks)) return callback(new Error("First argument to waterfall must be an array of functions")); if (!tasks.length) return callback(); var taskIndex = 0; function nextTask(args) { var task = wrapAsync(tasks[taskIndex++]); args.push(onlyOnce(next)); task.apply(null, args) } function next(err) { if (err || taskIndex === tasks.length) { return callback.apply(null, arguments) } nextTask(slice(arguments, 1)) } nextTask([]) }; var index = { applyEach: applyEach, applyEachSeries: applyEachSeries, apply: apply, asyncify: asyncify, auto: auto, autoInject: autoInject, cargo: cargo, compose: compose, concat: concat, concatLimit: concatLimit, concatSeries: concatSeries, constant: constant, detect: detect, detectLimit: detectLimit, detectSeries: detectSeries, dir: dir, doDuring: doDuring, doUntil: doUntil, doWhilst: doWhilst, during: during, each: eachLimit, eachLimit: eachLimit$1, eachOf: eachOf, eachOfLimit: eachOfLimit, eachOfSeries: eachOfSeries, eachSeries: eachSeries, ensureAsync: ensureAsync, every: every, everyLimit: everyLimit, everySeries: everySeries, filter: filter, filterLimit: filterLimit, filterSeries: filterSeries, forever: forever, groupBy: groupBy, groupByLimit: groupByLimit, groupBySeries: groupBySeries, log: log, map: map, mapLimit: mapLimit, mapSeries: mapSeries, mapValues: mapValues, mapValuesLimit: mapValuesLimit, mapValuesSeries: mapValuesSeries, memoize: memoize, nextTick: nextTick, parallel: parallelLimit, parallelLimit: parallelLimit$1, priorityQueue: priorityQueue, queue: queue$1, race: race, reduce: reduce, reduceRight: reduceRight, reflect: reflect, reflectAll: reflectAll, reject: reject, rejectLimit: rejectLimit, rejectSeries: rejectSeries, retry: retry, retryable: retryable, seq: seq, series: series, setImmediate: setImmediate$1, some: some, someLimit: someLimit, someSeries: someSeries, sortBy: sortBy, timeout: timeout, times: times, timesLimit: timeLimit, timesSeries: timesSeries, transform: transform, tryEach: tryEach, unmemoize: unmemoize, until: until, waterfall: waterfall, whilst: whilst, all: every, any: some, forEach: eachLimit, forEachSeries: eachSeries, forEachLimit: eachLimit$1, forEachOf: eachOf, forEachOfSeries: eachOfSeries, forEachOfLimit: eachOfLimit, inject: reduce, foldl: reduce, foldr: reduceRight, select: filter, selectLimit: filterLimit, selectSeries: filterSeries, wrapSync: asyncify }; exports["default"] = index; exports.applyEach = applyEach; exports.applyEachSeries = applyEachSeries; exports.apply = apply; exports.asyncify = asyncify; exports.auto = auto; exports.autoInject = autoInject; exports.cargo = cargo; exports.compose = compose; exports.concat = concat; exports.concatLimit = concatLimit; exports.concatSeries = concatSeries; exports.constant = constant; exports.detect = detect; exports.detectLimit = detectLimit; exports.detectSeries = detectSeries; exports.dir = dir; exports.doDuring = doDuring; exports.doUntil = doUntil; exports.doWhilst = doWhilst; exports.during = during; exports.each = eachLimit; exports.eachLimit = eachLimit$1; exports.eachOf = eachOf; exports.eachOfLimit = eachOfLimit; exports.eachOfSeries = eachOfSeries; exports.eachSeries = eachSeries; exports.ensureAsync = ensureAsync; exports.every = every; exports.everyLimit = everyLimit; exports.everySeries = everySeries; exports.filter = filter; exports.filterLimit = filterLimit; exports.filterSeries = filterSeries; exports.forever = forever; exports.groupBy = groupBy; exports.groupByLimit = groupByLimit; exports.groupBySeries = groupBySeries; exports.log = log; exports.map = map; exports.mapLimit = mapLimit; exports.mapSeries = mapSeries; exports.mapValues = mapValues; exports.mapValuesLimit = mapValuesLimit; exports.mapValuesSeries = mapValuesSeries; exports.memoize = memoize; exports.nextTick = nextTick; exports.parallel = parallelLimit; exports.parallelLimit = parallelLimit$1; exports.priorityQueue = priorityQueue; exports.queue = queue$1; exports.race = race; exports.reduce = reduce; exports.reduceRight = reduceRight; exports.reflect = reflect; exports.reflectAll = reflectAll; exports.reject = reject; exports.rejectLimit = rejectLimit; exports.rejectSeries = rejectSeries; exports.retry = retry; exports.retryable = retryable; exports.seq = seq; exports.series = series; exports.setImmediate = setImmediate$1; exports.some = some; exports.someLimit = someLimit; exports.someSeries = someSeries; exports.sortBy = sortBy; exports.timeout = timeout; exports.times = times; exports.timesLimit = timeLimit; exports.timesSeries = timesSeries; exports.transform = transform; exports.tryEach = tryEach; exports.unmemoize = unmemoize; exports.until = until; exports.waterfall = waterfall; exports.whilst = whilst; exports.all = every; exports.allLimit = everyLimit; exports.allSeries = everySeries; exports.any = some; exports.anyLimit = someLimit; exports.anySeries = someSeries; exports.find = detect; exports.findLimit = detectLimit; exports.findSeries = detectSeries; exports.forEach = eachLimit; exports.forEachSeries = eachSeries; exports.forEachLimit = eachLimit$1; exports.forEachOf = eachOf; exports.forEachOfSeries = eachOfSeries; exports.forEachOfLimit = eachOfLimit; exports.inject = reduce; exports.foldl = reduce; exports.foldr = reduceRight; exports.select = filter; exports.selectLimit = filterLimit; exports.selectSeries = filterSeries; exports.wrapSync = asyncify; Object.defineProperty(exports, "__esModule", { value: true }) }) }).call(this, require("_process"), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}) }, { _process: 10 }], 4: [function (require, module, exports) { "use strict"; exports.byteLength = byteLength; exports.toByteArray = toByteArray; exports.fromByteArray = fromByteArray; var lookup = []; var revLookup = []; var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array; var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; for (var i = 0, len = code.length; i < len; ++i) { lookup[i] = code[i]; revLookup[code.charCodeAt(i)] = i } revLookup["-".charCodeAt(0)] = 62; revLookup["_".charCodeAt(0)] = 63; function placeHoldersCount(b64) { var len = b64.length; if (len % 4 > 0) { throw new Error("Invalid string. Length must be a multiple of 4") } return b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0 } function byteLength(b64) { return b64.length * 3 / 4 - placeHoldersCount(b64) } function toByteArray(b64) { var i, l, tmp, placeHolders, arr; var len = b64.length; placeHolders = placeHoldersCount(b64); arr = new Arr(len * 3 / 4 - placeHolders); l = placeHolders > 0 ? len - 4 : len; var L = 0; for (i = 0; i < l; i += 4) { tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)]; arr[L++] = tmp >> 16 & 255; arr[L++] = tmp >> 8 & 255; arr[L++] = tmp & 255 } if (placeHolders === 2) { tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4; arr[L++] = tmp & 255 } else if (placeHolders === 1) { tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2; arr[L++] = tmp >> 8 & 255; arr[L++] = tmp & 255 } return arr } function tripletToBase64(num) { return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63] } function encodeChunk(uint8, start, end) { var tmp; var output = []; for (var i = start; i < end; i += 3) { tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2]; output.push(tripletToBase64(tmp)) } return output.join("") } function fromByteArray(uint8) { var tmp; var len = uint8.length; var extraBytes = len % 3; var output = ""; var parts = []; var maxChunkLength = 16383; for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) { parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength)) } if (extraBytes === 1) { tmp = uint8[len - 1]; output += lookup[tmp >> 2]; output += lookup[tmp << 4 & 63]; output += "==" } else if (extraBytes === 2) { tmp = (uint8[len - 2] << 8) + uint8[len - 1]; output += lookup[tmp >> 10]; output += lookup[tmp >> 4 & 63]; output += lookup[tmp << 2 & 63]; output += "=" } parts.push(output); return parts.join("") } }, {}], 5: [function (require, module, exports) { (function (global) { "use strict"; var base64 = require("base64-js"); var ieee754 = require("ieee754"); var isArray = require("isarray"); exports.Buffer = Buffer; exports.SlowBuffer = SlowBuffer; exports.INSPECT_MAX_BYTES = 50; Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport(); exports.kMaxLength = kMaxLength(); function typedArraySupport() { try { var arr = new Uint8Array(1); arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }; return arr.foo() === 42 && typeof arr.subarray === "function" && arr.subarray(1, 1).byteLength === 0 } catch (e) { return false } } function kMaxLength() { return Buffer.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823 } function createBuffer(that, length) { if (kMaxLength() < length) { throw new RangeError("Invalid typed array length") } if (Buffer.TYPED_ARRAY_SUPPORT) { that = new Uint8Array(length); that.__proto__ = Buffer.prototype } else { if (that === null) { that = new Buffer(length) } that.length = length } return that } function Buffer(arg, encodingOrOffset, length) { if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) { return new Buffer(arg, encodingOrOffset, length) } if (typeof arg === "number") { if (typeof encodingOrOffset === "string") { throw new Error("If encoding is specified then the first argument must be a string") } return allocUnsafe(this, arg) } return from(this, arg, encodingOrOffset, length) } Buffer.poolSize = 8192; Buffer._augment = function (arr) { arr.__proto__ = Buffer.prototype; return arr }; function from(that, value, encodingOrOffset, length) { if (typeof value === "number") { throw new TypeError('"value" argument must not be a number') } if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) { return fromArrayBuffer(that, value, encodingOrOffset, length) } if (typeof value === "string") { return fromString(that, value, encodingOrOffset) } return fromObject(that, value) } Buffer.from = function (value, encodingOrOffset, length) { return from(null, value, encodingOrOffset, length) }; if (Buffer.TYPED_ARRAY_SUPPORT) { Buffer.prototype.__proto__ = Uint8Array.prototype; Buffer.__proto__ = Uint8Array; if (typeof Symbol !== "undefined" && Symbol.species && Buffer[Symbol.species] === Buffer) { Object.defineProperty(Buffer, Symbol.species, { value: null, configurable: true }) } } function assertSize(size) { if (typeof size !== "number") { throw new TypeError('"size" argument must be a number') } else if (size < 0) { throw new RangeError('"size" argument must not be negative') } } function alloc(that, size, fill, encoding) { assertSize(size); if (size <= 0) { return createBuffer(that, size) } if (fill !== undefined) { return typeof encoding === "string" ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill) } return createBuffer(that, size) } Buffer.alloc = function (size, fill, encoding) { return alloc(null, size, fill, encoding) }; function allocUnsafe(that, size) { assertSize(size); that = createBuffer(that, size < 0 ? 0 : checked(size) | 0); if (!Buffer.TYPED_ARRAY_SUPPORT) { for (var i = 0; i < size; ++i) { that[i] = 0 } } return that } Buffer.allocUnsafe = function (size) { return allocUnsafe(null, size) }; Buffer.allocUnsafeSlow = function (size) { return allocUnsafe(null, size) }; function fromString(that, string, encoding) { if (typeof encoding !== "string" || encoding === "") { encoding = "utf8" } if (!Buffer.isEncoding(encoding)) { throw new TypeError('"encoding" must be a valid string encoding') } var length = byteLength(string, encoding) | 0; that = createBuffer(that, length); var actual = that.write(string, encoding); if (actual !== length) { that = that.slice(0, actual) } return that } function fromArrayLike(that, array) { var length = array.length < 0 ? 0 : checked(array.length) | 0; that = createBuffer(that, length); for (var i = 0; i < length; i += 1) { that[i] = array[i] & 255 } return that } function fromArrayBuffer(that, array, byteOffset, length) { array.byteLength; if (byteOffset < 0 || array.byteLength < byteOffset) { throw new RangeError("'offset' is out of bounds") } if (array.byteLength < byteOffset + (length || 0)) { throw new RangeError("'length' is out of bounds") } if (byteOffset === undefined && length === undefined) { array = new Uint8Array(array) } else if (length === undefined) { array = new Uint8Array(array, byteOffset) } else { array = new Uint8Array(array, byteOffset, length) } if (Buffer.TYPED_ARRAY_SUPPORT) { that = array; that.__proto__ = Buffer.prototype } else { that = fromArrayLike(that, array) } return that } function fromObject(that, obj) { if (Buffer.isBuffer(obj)) { var len = checked(obj.length) | 0; that = createBuffer(that, len); if (that.length === 0) { return that } obj.copy(that, 0, 0, len); return that } if (obj) { if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) { if (typeof obj.length !== "number" || isnan(obj.length)) { return createBuffer(that, 0) } return fromArrayLike(that, obj) } if (obj.type === "Buffer" && isArray(obj.data)) { return fromArrayLike(that, obj.data) } } throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.") } function checked(length) { if (length >= kMaxLength()) { throw new RangeError("Attempt to allocate Buffer larger than maximum " + "size: 0x" + kMaxLength().toString(16) + " bytes") } return length | 0 } function SlowBuffer(length) { if (+length != length) { length = 0 } return Buffer.alloc(+length) } Buffer.isBuffer = function isBuffer(b) { return !!(b != null && b._isBuffer) }; Buffer.compare = function compare(a, b) { if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) { throw new TypeError("Arguments must be Buffers") } if (a === b) return 0; var x = a.length; var y = b.length; for (var i = 0, len = Math.min(x, y) ; i < len; ++i) { if (a[i] !== b[i]) { x = a[i]; y = b[i]; break } } if (x < y) return -1; if (y < x) return 1; return 0 }; Buffer.isEncoding = function isEncoding(encoding) { switch (String(encoding).toLowerCase()) { case "hex": case "utf8": case "utf-8": case "ascii": case "latin1": case "binary": case "base64": case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return true; default: return false } }; Buffer.concat = function concat(list, length) { if (!isArray(list)) { throw new TypeError('"list" argument must be an Array of Buffers') } if (list.length === 0) { return Buffer.alloc(0) } var i; if (length === undefined) { length = 0; for (i = 0; i < list.length; ++i) { length += list[i].length } } var buffer = Buffer.allocUnsafe(length); var pos = 0; for (i = 0; i < list.length; ++i) { var buf = list[i]; if (!Buffer.isBuffer(buf)) { throw new TypeError('"list" argument must be an Array of Buffers') } buf.copy(buffer, pos); pos += buf.length } return buffer }; function byteLength(string, encoding) { if (Buffer.isBuffer(string)) { return string.length } if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) { return string.byteLength } if (typeof string !== "string") { string = "" + string } var len = string.length; if (len === 0) return 0; var loweredCase = false; for (; ;) { switch (encoding) { case "ascii": case "latin1": case "binary": return len; case "utf8": case "utf-8": case undefined: return utf8ToBytes(string).length; case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return len * 2; case "hex": return len >>> 1; case "base64": return base64ToBytes(string).length; default: if (loweredCase) return utf8ToBytes(string).length; encoding = ("" + encoding).toLowerCase(); loweredCase = true } } } Buffer.byteLength = byteLength; function slowToString(encoding, start, end) { var loweredCase = false; if (start === undefined || start < 0) { start = 0 } if (start > this.length) { return "" } if (end === undefined || end > this.length) { end = this.length } if (end <= 0) { return "" } end >>>= 0; start >>>= 0; if (end <= start) { return "" } if (!encoding) encoding = "utf8"; while (true) { switch (encoding) { case "hex": return hexSlice(this, start, end); case "utf8": case "utf-8": return utf8Slice(this, start, end); case "ascii": return asciiSlice(this, start, end); case "latin1": case "binary": return latin1Slice(this, start, end); case "base64": return base64Slice(this, start, end); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return utf16leSlice(this, start, end); default: if (loweredCase) throw new TypeError("Unknown encoding: " + encoding); encoding = (encoding + "").toLowerCase(); loweredCase = true } } } Buffer.prototype._isBuffer = true; function swap(b, n, m) { var i = b[n]; b[n] = b[m]; b[m] = i } Buffer.prototype.swap16 = function swap16() { var len = this.length; if (len % 2 !== 0) { throw new RangeError("Buffer size must be a multiple of 16-bits") } for (var i = 0; i < len; i += 2) { swap(this, i, i + 1) } return this }; Buffer.prototype.swap32 = function swap32() { var len = this.length; if (len % 4 !== 0) { throw new RangeError("Buffer size must be a multiple of 32-bits") } for (var i = 0; i < len; i += 4) { swap(this, i, i + 3); swap(this, i + 1, i + 2) } return this }; Buffer.prototype.swap64 = function swap64() { var len = this.length; if (len % 8 !== 0) { throw new RangeError("Buffer size must be a multiple of 64-bits") } for (var i = 0; i < len; i += 8) { swap(this, i, i + 7); swap(this, i + 1, i + 6); swap(this, i + 2, i + 5); swap(this, i + 3, i + 4) } return this }; Buffer.prototype.toString = function toString() { var length = this.length | 0; if (length === 0) return ""; if (arguments.length === 0) return utf8Slice(this, 0, length); return slowToString.apply(this, arguments) }; Buffer.prototype.equals = function equals(b) { if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer"); if (this === b) return true; return Buffer.compare(this, b) === 0 }; Buffer.prototype.inspect = function inspect() { var str = ""; var max = exports.INSPECT_MAX_BYTES; if (this.length > 0) { str = this.toString("hex", 0, max).match(/.{2}/g).join(" "); if (this.length > max) str += " ... " } return "<Buffer " + str + ">" }; Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) { if (!Buffer.isBuffer(target)) { throw new TypeError("Argument must be a Buffer") } if (start === undefined) { start = 0 } if (end === undefined) { end = target ? target.length : 0 } if (thisStart === undefined) { thisStart = 0 } if (thisEnd === undefined) { thisEnd = this.length } if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) { throw new RangeError("out of range index") } if (thisStart >= thisEnd && start >= end) { return 0 } if (thisStart >= thisEnd) { return -1 } if (start >= end) { return 1 } start >>>= 0; end >>>= 0; thisStart >>>= 0; thisEnd >>>= 0; if (this === target) return 0; var x = thisEnd - thisStart; var y = end - start; var len = Math.min(x, y); var thisCopy = this.slice(thisStart, thisEnd); var targetCopy = target.slice(start, end); for (var i = 0; i < len; ++i) { if (thisCopy[i] !== targetCopy[i]) { x = thisCopy[i]; y = targetCopy[i]; break } } if (x < y) return -1; if (y < x) return 1; return 0 }; function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) { if (buffer.length === 0) return -1; if (typeof byteOffset === "string") { encoding = byteOffset; byteOffset = 0 } else if (byteOffset > 2147483647) { byteOffset = 2147483647 } else if (byteOffset < -2147483648) { byteOffset = -2147483648 } byteOffset = +byteOffset; if (isNaN(byteOffset)) { byteOffset = dir ? 0 : buffer.length - 1 } if (byteOffset < 0) byteOffset = buffer.length + byteOffset; if (byteOffset >= buffer.length) { if (dir) return -1; else byteOffset = buffer.length - 1 } else if (byteOffset < 0) { if (dir) byteOffset = 0; else return -1 } if (typeof val === "string") { val = Buffer.from(val, encoding) } if (Buffer.isBuffer(val)) { if (val.length === 0) { return -1 } return arrayIndexOf(buffer, val, byteOffset, encoding, dir) } else if (typeof val === "number") { val = val & 255; if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") { if (dir) { return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset) } else { return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset) } } return arrayIndexOf(buffer, [val], byteOffset, encoding, dir) } throw new TypeError("val must be string, number or Buffer") } function arrayIndexOf(arr, val, byteOffset, encoding, dir) { var indexSize = 1; var arrLength = arr.length; var valLength = val.length; if (encoding !== undefined) { encoding = String(encoding).toLowerCase(); if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") { if (arr.length < 2 || val.length < 2) { return -1 } indexSize = 2; arrLength /= 2; valLength /= 2; byteOffset /= 2 } } function read(buf, i) { if (indexSize === 1) { return buf[i] } else { return buf.readUInt16BE(i * indexSize) } } var i; if (dir) { var foundIndex = -1; for (i = byteOffset; i < arrLength; i++) { if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) { if (foundIndex === -1) foundIndex = i; if (i - foundIndex + 1 === valLength) return foundIndex * indexSize } else { if (foundIndex !== -1) i -= i - foundIndex; foundIndex = -1 } } } else { if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength; for (i = byteOffset; i >= 0; i--) { var found = true; for (var j = 0; j < valLength; j++) { if (read(arr, i + j) !== read(val, j)) { found = false; break } } if (found) return i } } return -1 } Buffer.prototype.includes = function includes(val, byteOffset, encoding) { return this.indexOf(val, byteOffset, encoding) !== -1 }; Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) { return bidirectionalIndexOf(this, val, byteOffset, encoding, true) }; Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) { return bidirectionalIndexOf(this, val, byteOffset, encoding, false) }; function hexWrite(buf, string, offset, length) { offset = Number(offset) || 0; var remaining = buf.length - offset; if (!length) { length = remaining } else { length = Number(length); if (length > remaining) { length = remaining } } var strLen = string.length; if (strLen % 2 !== 0) throw new TypeError("Invalid hex string"); if (length > strLen / 2) { length = strLen / 2 } for (var i = 0; i < length; ++i) { var parsed = parseInt(string.substr(i * 2, 2), 16); if (isNaN(parsed)) return i; buf[offset + i] = parsed } return i } function utf8Write(buf, string, offset, length) { return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length) } function asciiWrite(buf, string, offset, length) { return blitBuffer(asciiToBytes(string), buf, offset, length) } function latin1Write(buf, string, offset, length) { return asciiWrite(buf, string, offset, length) } function base64Write(buf, string, offset, length) { return blitBuffer(base64ToBytes(string), buf, offset, length) } function ucs2Write(buf, string, offset, length) { return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length) } Buffer.prototype.write = function write(string, offset, length, encoding) { if (offset === undefined) { encoding = "utf8"; length = this.length; offset = 0 } else if (length === undefined && typeof offset === "string") { encoding = offset; length = this.length; offset = 0 } else if (isFinite(offset)) { offset = offset | 0; if (isFinite(length)) { length = length | 0; if (encoding === undefined) encoding = "utf8" } else { encoding = length; length = undefined } } else { throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported") } var remaining = this.length - offset; if (length === undefined || length > remaining) length = remaining; if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) { throw new RangeError("Attempt to write outside buffer bounds") } if (!encoding) encoding = "utf8"; var loweredCase = false; for (; ;) { switch (encoding) { case "hex": return hexWrite(this, string, offset, length); case "utf8": case "utf-8": return utf8Write(this, string, offset, length); case "ascii": return asciiWrite(this, string, offset, length); case "latin1": case "binary": return latin1Write(this, string, offset, length); case "base64": return base64Write(this, string, offset, length); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return ucs2Write(this, string, offset, length); default: if (loweredCase) throw new TypeError("Unknown encoding: " + encoding); encoding = ("" + encoding).toLowerCase(); loweredCase = true } } }; Buffer.prototype.toJSON = function toJSON() { return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) } }; function base64Slice(buf, start, end) { if (start === 0 && end === buf.length) { return base64.fromByteArray(buf) } else { return base64.fromByteArray(buf.slice(start, end)) } } function utf8Slice(buf, start, end) { end = Math.min(buf.length, end); var res = []; var i = start; while (i < end) { var firstByte = buf[i]; var codePoint = null; var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1; if (i + bytesPerSequence <= end) { var secondByte, thirdByte, fourthByte, tempCodePoint; switch (bytesPerSequence) { case 1: if (firstByte < 128) { codePoint = firstByte } break; case 2: secondByte = buf[i + 1]; if ((secondByte & 192) === 128) { tempCodePoint = (firstByte & 31) << 6 | secondByte & 63; if (tempCodePoint > 127) { codePoint = tempCodePoint } } break; case 3: secondByte = buf[i + 1]; thirdByte = buf[i + 2]; if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) { tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63; if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) { codePoint = tempCodePoint } } break; case 4: secondByte = buf[i + 1]; thirdByte = buf[i + 2]; fourthByte = buf[i + 3]; if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) { tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63; if (tempCodePoint > 65535 && tempCodePoint < 1114112) { codePoint = tempCodePoint } } } } if (codePoint === null) { codePoint = 65533; bytesPerSequence = 1 } else if (codePoint > 65535) { codePoint -= 65536; res.push(codePoint >>> 10 & 1023 | 55296); codePoint = 56320 | codePoint & 1023 } res.push(codePoint); i += bytesPerSequence } return decodeCodePointsArray(res) } var MAX_ARGUMENTS_LENGTH = 4096; function decodeCodePointsArray(codePoints) { var len = codePoints.length; if (len <= MAX_ARGUMENTS_LENGTH) { return String.fromCharCode.apply(String, codePoints) } var res = ""; var i = 0; while (i < len) { res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)) } return res } function asciiSlice(buf, start, end) { var ret = ""; end = Math.min(buf.length, end); for (var i = start; i < end; ++i) { ret += String.fromCharCode(buf[i] & 127) } return ret } function latin1Slice(buf, start, end) { var ret = ""; end = Math.min(buf.length, end); for (var i = start; i < end; ++i) { ret += String.fromCharCode(buf[i]) } return ret } function hexSlice(buf, start, end) { var len = buf.length; if (!start || start < 0) start = 0; if (!end || end < 0 || end > len) end = len; var out = ""; for (var i = start; i < end; ++i) { out += toHex(buf[i]) } return out } function utf16leSlice(buf, start, end) { var bytes = buf.slice(start, end); var res = ""; for (var i = 0; i < bytes.length; i += 2) { res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256) } return res } Buffer.prototype.slice = function slice(start, end) { var len = this.length; start = ~~start; end = end === undefined ? len : ~~end; if (start < 0) { start += len; if (start < 0) start = 0 } else if (start > len) { start = len } if (end < 0) { end += len; if (end < 0) end = 0 } else if (end > len) { end = len } if (end < start) end = start; var newBuf; if (Buffer.TYPED_ARRAY_SUPPORT) { newBuf = this.subarray(start, end); newBuf.__proto__ = Buffer.prototype } else { var sliceLen = end - start; newBuf = new Buffer(sliceLen, undefined); for (var i = 0; i < sliceLen; ++i) { newBuf[i] = this[i + start] } } return newBuf }; function checkOffset(offset, ext, length) { if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint"); if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length") } Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) { offset = offset | 0; byteLength = byteLength | 0; if (!noAssert) checkOffset(offset, byteLength, this.length); var val = this[offset]; var mul = 1; var i = 0; while (++i < byteLength && (mul *= 256)) { val += this[offset + i] * mul } return val }; Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) { offset = offset | 0; byteLength = byteLength | 0; if (!noAssert) { checkOffset(offset, byteLength, this.length) } var val = this[offset + --byteLength]; var mul = 1; while (byteLength > 0 && (mul *= 256)) { val += this[offset + --byteLength] * mul } return val }; Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) { if (!noAssert) checkOffset(offset, 1, this.length); return this[offset] }; Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) { if (!noAssert) checkOffset(offset, 2, this.length); return this[offset] | this[offset + 1] << 8 }; Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) { if (!noAssert) checkOffset(offset, 2, this.length); return this[offset] << 8 | this[offset + 1] }; Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) { if (!noAssert) checkOffset(offset, 4, this.length); return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216 }; Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) { if (!noAssert) checkOffset(offset, 4, this.length); return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]) }; Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) { offset = offset | 0; byteLength = byteLength | 0; if (!noAssert) checkOffset(offset, byteLength, this.length); var val = this[offset]; var mul = 1; var i = 0; while (++i < byteLength && (mul *= 256)) { val += this[offset + i] * mul } mul *= 128; if (val >= mul) val -= Math.pow(2, 8 * byteLength); return val }; Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) { offset = offset | 0; byteLength = byteLength | 0; if (!noAssert) checkOffset(offset, byteLength, this.length); var i = byteLength; var mul = 1; var val = this[offset + --i]; while (i > 0 && (mul *= 256)) { val += this[offset + --i] * mul } mul *= 128; if (val >= mul) val -= Math.pow(2, 8 * byteLength); return val }; Buffer.prototype.readInt8 = function readInt8(offset, noAssert) { if (!noAssert) checkOffset(offset, 1, this.length); if (!(this[offset] & 128)) return this[offset]; return (255 - this[offset] + 1) * -1 }; Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) { if (!noAssert) checkOffset(offset, 2, this.length); var val = this[offset] | this[offset + 1] << 8; return val & 32768 ? val | 4294901760 : val }; Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) { if (!noAssert) checkOffset(offset, 2, this.length); var val = this[offset + 1] | this[offset] << 8; return val & 32768 ? val | 4294901760 : val }; Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) { if (!noAssert) checkOffset(offset, 4, this.length); return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24 }; Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) { if (!noAssert) checkOffset(offset, 4, this.length); return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3] }; Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) { if (!noAssert) checkOffset(offset, 4, this.length); return ieee754.read(this, offset, true, 23, 4) }; Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) { if (!noAssert) checkOffset(offset, 4, this.length); return ieee754.read(this, offset, false, 23, 4) }; Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) { if (!noAssert) checkOffset(offset, 8, this.length); return ieee754.read(this, offset, true, 52, 8) }; Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) { if (!noAssert) checkOffset(offset, 8, this.length); return ieee754.read(this, offset, false, 52, 8) }; function checkInt(buf, value, offset, ext, max, min) { if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance'); if (value > max || value < min) throw new RangeError('"value" argument is out of bounds'); if (offset + ext > buf.length) throw new RangeError("Index out of range") } Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) { value = +value; offset = offset | 0; byteLength = byteLength | 0; if (!noAssert) { var maxBytes = Math.pow(2, 8 * byteLength) - 1; checkInt(this, value, offset, byteLength, maxBytes, 0) } var mul = 1; var i = 0; this[offset] = value & 255; while (++i < byteLength && (mul *= 256)) { this[offset + i] = value / mul & 255 } return offset + byteLength }; Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) { value = +value; offset = offset | 0; byteLength = byteLength | 0; if (!noAssert) { var maxBytes = Math.pow(2, 8 * byteLength) - 1; checkInt(this, value, offset, byteLength, maxBytes, 0) } var i = byteLength - 1; var mul = 1; this[offset + i] = value & 255; while (--i >= 0 && (mul *= 256)) { this[offset + i] = value / mul & 255 } return offset + byteLength }; Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) { value = +value; offset = offset | 0; if (!noAssert) checkInt(this, value, offset, 1, 255, 0); if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value); this[offset] = value & 255; return offset + 1 }; function objectWriteUInt16(buf, value, offset, littleEndian) { if (value < 0) value = 65535 + value + 1; for (var i = 0, j = Math.min(buf.length - offset, 2) ; i < j; ++i) { buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8 } } Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) { value = +value; offset = offset | 0; if (!noAssert) checkInt(this, value, offset, 2, 65535, 0); if (Buffer.TYPED_ARRAY_SUPPORT) { this[offset] = value & 255; this[offset + 1] = value >>> 8 } else { objectWriteUInt16(this, value, offset, true) } return offset + 2 }; Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) { value = +value; offset = offset | 0; if (!noAssert) checkInt(this, value, offset, 2, 65535, 0); if (Buffer.TYPED_ARRAY_SUPPORT) { this[offset] = value >>> 8; this[offset + 1] = value & 255 } else { objectWriteUInt16(this, value, offset, false) } return offset + 2 }; function objectWriteUInt32(buf, value, offset, littleEndian) { if (value < 0) value = 4294967295 + value + 1; for (var i = 0, j = Math.min(buf.length - offset, 4) ; i < j; ++i) { buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255 } } Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) { value = +value; offset = offset | 0; if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0); if (Buffer.TYPED_ARRAY_SUPPORT) { this[offset + 3] = value >>> 24; this[offset + 2] = value >>> 16; this[offset + 1] = value >>> 8; this[offset] = value & 255 } else { objectWriteUInt32(this, value, offset, true) } return offset + 4 }; Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) { value = +value; offset = offset | 0; if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0); if (Buffer.TYPED_ARRAY_SUPPORT) { this[offset] = value >>> 24; this[offset + 1] = value >>> 16; this[offset + 2] = value >>> 8; this[offset + 3] = value & 255 } else { objectWriteUInt32(this, value, offset, false) } return offset + 4 }; Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) { value = +value; offset = offset | 0; if (!noAssert) { var limit = Math.pow(2, 8 * byteLength - 1); checkInt(this, value, offset, byteLength, limit - 1, -limit) } var i = 0; var mul = 1; var sub = 0; this[offset] = value & 255; while (++i < byteLength && (mul *= 256)) { if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) { sub = 1 } this[offset + i] = (value / mul >> 0) - sub & 255 } return offset + byteLength }; Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) { value = +value; offset = offset | 0; if (!noAssert) { var limit = Math.pow(2, 8 * byteLength - 1); checkInt(this, value, offset, byteLength, limit - 1, -limit) } var i = byteLength - 1; var mul = 1; var sub = 0; this[offset + i] = value & 255; while (--i >= 0 && (mul *= 256)) { if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) { sub = 1 } this[offset + i] = (value / mul >> 0) - sub & 255 } return offset + byteLength }; Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) { value = +value; offset = offset | 0; if (!noAssert) checkInt(this, value, offset, 1, 127, -128); if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value); if (value < 0) value = 255 + value + 1; this[offset] = value & 255; return offset + 1 }; Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) { value = +value; offset = offset | 0; if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768); if (Buffer.TYPED_ARRAY_SUPPORT) { this[offset] = value & 255; this[offset + 1] = value >>> 8 } else { objectWriteUInt16(this, value, offset, true) } return offset + 2 }; Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) { value = +value; offset = offset | 0; if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768); if (Buffer.TYPED_ARRAY_SUPPORT) { this[offset] = value >>> 8; this[offset + 1] = value & 255 } else { objectWriteUInt16(this, value, offset, false) } return offset + 2 }; Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) { value = +value; offset = offset | 0; if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648); if (Buffer.TYPED_ARRAY_SUPPORT) { this[offset] = value & 255; this[offset + 1] = value >>> 8; this[offset + 2] = value >>> 16; this[offset + 3] = value >>> 24 } else { objectWriteUInt32(this, value, offset, true) } return offset + 4 }; Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) { value = +value; offset = offset | 0; if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648); if (value < 0) value = 4294967295 + value + 1; if (Buffer.TYPED_ARRAY_SUPPORT) { this[offset] = value >>> 24; this[offset + 1] = value >>> 16; this[offset + 2] = value >>> 8; this[offset + 3] = value & 255 } else { objectWriteUInt32(this, value, offset, false) } return offset + 4 }; function checkIEEE754(buf, value, offset, ext, max, min) { if (offset + ext > buf.length) throw new RangeError("Index out of range"); if (offset < 0) throw new RangeError("Index out of range") } function writeFloat(buf, value, offset, littleEndian, noAssert) { if (!noAssert) { checkIEEE754(buf, value, offset, 4, 3.4028234663852886e38, -3.4028234663852886e38) } ieee754.write(buf, value, offset, littleEndian, 23, 4); return offset + 4 } Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) { return writeFloat(this, value, offset, true, noAssert) }; Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) { return writeFloat(this, value, offset, false, noAssert) }; function writeDouble(buf, value, offset, littleEndian, noAssert) { if (!noAssert) { checkIEEE754(buf, value, offset, 8, 1.7976931348623157e308, -1.7976931348623157e308) } ieee754.write(buf, value, offset, littleEndian, 52, 8); return offset + 8 } Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) { return writeDouble(this, value, offset, true, noAssert) }; Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) { return writeDouble(this, value, offset, false, noAssert) }; Buffer.prototype.copy = function copy(target, targetStart, start, end) { if (!start) start = 0; if (!end && end !== 0) end = this.length; if (targetStart >= target.length) targetStart = target.length; if (!targetStart) targetStart = 0; if (end > 0 && end < start) end = start; if (end === start) return 0; if (target.length === 0 || this.length === 0) return 0; if (targetStart < 0) { throw new RangeError("targetStart out of bounds") } if (start < 0 || start >= this.length) throw new RangeError("sourceStart out of bounds"); if (end < 0) throw new RangeError("sourceEnd out of bounds"); if (end > this.length) end = this.length; if (target.length - targetStart < end - start) { end = target.length - targetStart + start } var len = end - start; var i; if (this === target && start < targetStart && targetStart < end) { for (i = len - 1; i >= 0; --i) { target[i + targetStart] = this[i + start] } } else if (len < 1e3 || !Buffer.TYPED_ARRAY_SUPPORT) { for (i = 0; i < len; ++i) { target[i + targetStart] = this[i + start] } } else { Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart) } return len }; Buffer.prototype.fill = function fill(val, start, end, encoding) { if (typeof val === "string") { if (typeof start === "string") { encoding = start; start = 0; end = this.length } else if (typeof end === "string") { encoding = end; end = this.length } if (val.length === 1) { var code = val.charCodeAt(0); if (code < 256) { val = code } } if (encoding !== undefined && typeof encoding !== "string") { throw new TypeError("encoding must be a string") } if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) { throw new TypeError("Unknown encoding: " + encoding) } } else if (typeof val === "number") { val = val & 255 } if (start < 0 || this.length < start || this.length < end) { throw new RangeError("Out of range index") } if (end <= start) { return this } start = start >>> 0; end = end === undefined ? this.length : end >>> 0; if (!val) val = 0; var i; if (typeof val === "number") { for (i = start; i < end; ++i) { this[i] = val } } else { var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString()); var len = bytes.length; for (i = 0; i < end - start; ++i) { this[i + start] = bytes[i % len] } } return this }; var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g; function base64clean(str) { str = stringtrim(str).replace(INVALID_BASE64_RE, ""); if (str.length < 2) return ""; while (str.length % 4 !== 0) { str = str + "=" } return str } function stringtrim(str) { if (str.trim) return str.trim(); return str.replace(/^\s+|\s+$/g, "") } function toHex(n) { if (n < 16) return "0" + n.toString(16); return n.toString(16) } function utf8ToBytes(string, units) { units = units || Infinity; var codePoint; var length = string.length; var leadSurrogate = null; var bytes = []; for (var i = 0; i < length; ++i) { codePoint = string.charCodeAt(i); if (codePoint > 55295 && codePoint < 57344) { if (!leadSurrogate) { if (codePoint > 56319) { if ((units -= 3) > -1) bytes.push(239, 191, 189); continue } else if (i + 1 === length) { if ((units -= 3) > -1) bytes.push(239, 191, 189); continue } leadSurrogate = codePoint; continue } if (codePoint < 56320) { if ((units -= 3) > -1) bytes.push(239, 191, 189); leadSurrogate = codePoint; continue } codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536 } else if (leadSurrogate) { if ((units -= 3) > -1) bytes.push(239, 191, 189) } leadSurrogate = null; if (codePoint < 128) { if ((units -= 1) < 0) break; bytes.push(codePoint) } else if (codePoint < 2048) { if ((units -= 2) < 0) break; bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128) } else if (codePoint < 65536) { if ((units -= 3) < 0) break; bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128) } else if (codePoint < 1114112) { if ((units -= 4) < 0) break; bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128) } else { throw new Error("Invalid code point") } } return bytes } function asciiToBytes(str) { var byteArray = []; for (var i = 0; i < str.length; ++i) { byteArray.push(str.charCodeAt(i) & 255) } return byteArray } function utf16leToBytes(str, units) { var c, hi, lo; var byteArray = []; for (var i = 0; i < str.length; ++i) { if ((units -= 2) < 0) break; c = str.charCodeAt(i); hi = c >> 8; lo = c % 256; byteArray.push(lo); byteArray.push(hi) } return byteArray } function base64ToBytes(str) { return base64.toByteArray(base64clean(str)) } function blitBuffer(src, dst, offset, length) { for (var i = 0; i < length; ++i) { if (i + offset >= dst.length || i >= src.length) break; dst[i + offset] = src[i] } return i } function isnan(val) { return val !== val } }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}) }, { "base64-js": 4, ieee754: 7, isarray: 8 }], 6: [function (require, module, exports) { var saveAs = saveAs || function (view) { "use strict"; if (typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) { return } var doc = view.document, get_URL = function () { return view.URL || view.webkitURL || view }, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a"), can_use_save_link = "download" in save_link, click = function (node) { var event = new MouseEvent("click"); node.dispatchEvent(event) }, webkit_req_fs = view.webkitRequestFileSystem, req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem, throw_outside = function (ex) { (view.setImmediate || view.setTimeout)(function () { throw ex }, 0) }, force_saveable_type = "application/octet-stream", fs_min_size = 0, arbitrary_revoke_timeout = 500, revoke = function (file) { var revoker = function () { if (typeof file === "string") { get_URL().revokeObjectURL(file) } else { file.remove() } }; if (view.chrome) { revoker() } else { setTimeout(revoker, arbitrary_revoke_timeout) } }, dispatch = function (filesaver, event_types, event) { event_types = [].concat(event_types); var i = event_types.length; while (i--) { var listener = filesaver["on" + event_types[i]]; if (typeof listener === "function") { try { listener.call(filesaver, event || filesaver) } catch (ex) { throw_outside(ex) } } } }, auto_bom = function (blob) { if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) { return new Blob(["\ufeff", blob], { type: blob.type }) } return blob }, FileSaver = function (blob, name, no_auto_bom) { if (!no_auto_bom) { blob = auto_bom(blob) } var filesaver = this, type = blob.type, blob_changed = false, object_url, target_view, dispatch_all = function () { dispatch(filesaver, "writestart progress write writeend".split(" ")) }, fs_error = function () { if (blob_changed || !object_url) { object_url = get_URL().createObjectURL(blob) } if (target_view) { target_view.location.href = object_url } else { var new_tab = view.open(object_url, "_blank"); if (new_tab == undefined && typeof safari !== "undefined") { view.location.href = object_url } } filesaver.readyState = filesaver.DONE; dispatch_all(); revoke(object_url) }, abortable = function (func) { return function () { if (filesaver.readyState !== filesaver.DONE) { return func.apply(this, arguments) } } }, create_if_not_found = { create: true, exclusive: false }, slice; filesaver.readyState = filesaver.INIT; if (!name) { name = "download" } if (can_use_save_link) { object_url = get_URL().createObjectURL(blob); save_link.href = object_url; save_link.download = name; setTimeout(function () { click(save_link); dispatch_all(); revoke(object_url); filesaver.readyState = filesaver.DONE }); return } if (view.chrome && type && type !== force_saveable_type) { slice = blob.slice || blob.webkitSlice; blob = slice.call(blob, 0, blob.size, force_saveable_type); blob_changed = true } if (webkit_req_fs && name !== "download") { name += ".download" } if (type === force_saveable_type || webkit_req_fs) { target_view = view } if (!req_fs) { fs_error(); return } fs_min_size += blob.size; req_fs(view.TEMPORARY, fs_min_size, abortable(function (fs) { fs.root.getDirectory("saved", create_if_not_found, abortable(function (dir) { var save = function () { dir.getFile(name, create_if_not_found, abortable(function (file) { file.createWriter(abortable(function (writer) { writer.onwriteend = function (event) { target_view.location.href = file.toURL(); filesaver.readyState = filesaver.DONE; dispatch(filesaver, "writeend", event); revoke(file) }; writer.onerror = function () { var error = writer.error; if (error.code !== error.ABORT_ERR) { fs_error() } }; "writestart progress write abort".split(" ").forEach(function (event) { writer["on" + event] = filesaver["on" + event] }); writer.write(blob); filesaver.abort = function () { writer.abort(); filesaver.readyState = filesaver.DONE }; filesaver.readyState = filesaver.WRITING }), fs_error) }), fs_error) }; dir.getFile(name, { create: false }, abortable(function (file) { file.remove(); save() }), abortable(function (ex) { if (ex.code === ex.NOT_FOUND_ERR) { save() } else { fs_error() } })) }), fs_error) }), fs_error) }, FS_proto = FileSaver.prototype, saveAs = function (blob, name, no_auto_bom) { return new FileSaver(blob, name, no_auto_bom) }; if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) { return function (blob, name, no_auto_bom) { if (!no_auto_bom) { blob = auto_bom(blob) } return navigator.msSaveOrOpenBlob(blob, name || "download") } } FS_proto.abort = function () { var filesaver = this; filesaver.readyState = filesaver.DONE; dispatch(filesaver, "abort") }; FS_proto.readyState = FS_proto.INIT = 0; FS_proto.WRITING = 1; FS_proto.DONE = 2; FS_proto.error = FS_proto.onwritestart = FS_proto.onprogress = FS_proto.onwrite = FS_proto.onabort = FS_proto.onerror = FS_proto.onwriteend = null; return saveAs }(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this.content); if (typeof module !== "undefined" && module.exports) { module.exports.saveAs = saveAs } else if (typeof define !== "undefined" && define !== null && define.amd != null) { define([], function () { return saveAs }) } }, {}], 7: [function (require, module, exports) { exports.read = function (buffer, offset, isLE, mLen, nBytes) { var e, m; var eLen = nBytes * 8 - mLen - 1; var eMax = (1 << eLen) - 1; var eBias = eMax >> 1; var nBits = -7; var i = isLE ? nBytes - 1 : 0; var d = isLE ? -1 : 1; var s = buffer[offset + i]; i += d; e = s & (1 << -nBits) - 1; s >>= -nBits; nBits += eLen; for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) { } m = e & (1 << -nBits) - 1; e >>= -nBits; nBits += mLen; for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) { } if (e === 0) { e = 1 - eBias } else if (e === eMax) { return m ? NaN : (s ? -1 : 1) * Infinity } else { m = m + Math.pow(2, mLen); e = e - eBias } return (s ? -1 : 1) * m * Math.pow(2, e - mLen) }; exports.write = function (buffer, value, offset, isLE, mLen, nBytes) { var e, m, c; var eLen = nBytes * 8 - mLen - 1; var eMax = (1 << eLen) - 1; var eBias = eMax >> 1; var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0; var i = isLE ? 0 : nBytes - 1; var d = isLE ? 1 : -1; var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0; value = Math.abs(value); if (isNaN(value) || value === Infinity) { m = isNaN(value) ? 1 : 0; e = eMax } else { e = Math.floor(Math.log(value) / Math.LN2); if (value * (c = Math.pow(2, -e)) < 1) { e--; c *= 2 } if (e + eBias >= 1) { value += rt / c } else { value += rt * Math.pow(2, 1 - eBias) } if (value * c >= 2) { e++; c /= 2 } if (e + eBias >= eMax) { m = 0; e = eMax } else if (e + eBias >= 1) { m = (value * c - 1) * Math.pow(2, mLen); e = e + eBias } else { m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen); e = 0 } } for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) { } e = e << mLen | m; eLen += mLen; for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) { } buffer[offset + i - d] |= s * 128 } }, {}], 8: [function (require, module, exports) { var toString = {}.toString; module.exports = Array.isArray || function (arr) { return toString.call(arr) == "[object Array]" } }, {}], 9: [function (require, module, exports) { (function (global) { "use strict"; var _Base64 = global.Base64; var version = "2.1.9"; var buffer; if (typeof module !== "undefined" && module.exports) { try { buffer = require("buffer").Buffer } catch (err) { } } var b64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; var b64tab = function (bin) { var t = {}; for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i; return t }(b64chars); var fromCharCode = String.fromCharCode; var cb_utob = function (c) { if (c.length < 2) { var cc = c.charCodeAt(0); return cc < 128 ? c : cc < 2048 ? fromCharCode(192 | cc >>> 6) + fromCharCode(128 | cc & 63) : fromCharCode(224 | cc >>> 12 & 15) + fromCharCode(128 | cc >>> 6 & 63) + fromCharCode(128 | cc & 63) } else { var cc = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320); return fromCharCode(240 | cc >>> 18 & 7) + fromCharCode(128 | cc >>> 12 & 63) + fromCharCode(128 | cc >>> 6 & 63) + fromCharCode(128 | cc & 63) } }; var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g; var utob = function (u) { return u.replace(re_utob, cb_utob) }; var cb_encode = function (ccc) { var padlen = [0, 2, 1][ccc.length % 3], ord = ccc.charCodeAt(0) << 16 | (ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8 | (ccc.length > 2 ? ccc.charCodeAt(2) : 0), chars = [b64chars.charAt(ord >>> 18), b64chars.charAt(ord >>> 12 & 63), padlen >= 2 ? "=" : b64chars.charAt(ord >>> 6 & 63), padlen >= 1 ? "=" : b64chars.charAt(ord & 63)]; return chars.join("") }; var btoa = global.btoa ? function (b) { return global.btoa(b) } : function (b) { return b.replace(/[\s\S]{1,3}/g, cb_encode) }; var _encode = buffer ? function (u) { return (u.constructor === buffer.constructor ? u : new buffer(u)).toString("base64") } : function (u) { return btoa(utob(u)) }; var encode = function (u, urisafe) { return !urisafe ? _encode(String(u)) : _encode(String(u)).replace(/[+\/]/g, function (m0) { return m0 == "+" ? "-" : "_" }).replace(/=/g, "") }; var encodeURI = function (u) { return encode(u, true) }; var re_btou = new RegExp(["[À-ß][-¿]", "[à-ï][-¿]{2}", "[ð-÷][-¿]{3}"].join("|"), "g"); var cb_btou = function (cccc) { switch (cccc.length) { case 4: var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp - 65536; return fromCharCode((offset >>> 10) + 55296) + fromCharCode((offset & 1023) + 56320); case 3: return fromCharCode((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2)); default: return fromCharCode((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1)) } }; var btou = function (b) { return b.replace(re_btou, cb_btou) }; var cb_decode = function (cccc) { var len = cccc.length, padlen = len % 4, n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0) | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0) | (len > 2 ? b64tab[cccc.charAt(2)] << 6 : 0) | (len > 3 ? b64tab[cccc.charAt(3)] : 0), chars = [fromCharCode(n >>> 16), fromCharCode(n >>> 8 & 255), fromCharCode(n & 255)]; chars.length -= [0, 0, 2, 1][padlen]; return chars.join("") }; var atob = global.atob ? function (a) { return global.atob(a) } : function (a) { return a.replace(/[\s\S]{1,4}/g, cb_decode) }; var _decode = buffer ? function (a) { return (a.constructor === buffer.constructor ? a : new buffer(a, "base64")).toString() } : function (a) { return btou(atob(a)) }; var decode = function (a) { return _decode(String(a).replace(/[-_]/g, function (m0) { return m0 == "-" ? "+" : "/" }).replace(/[^A-Za-z0-9\+\/]/g, "")) }; var noConflict = function () { var Base64 = global.Base64; global.Base64 = _Base64; return Base64 }; global.Base64 = { VERSION: version, atob: atob, btoa: btoa, fromBase64: decode, toBase64: encode, utob: utob, encode: encode, encodeURI: encodeURI, btou: btou, decode: decode, noConflict: noConflict }; if (typeof Object.defineProperty === "function") { var noEnum = function (v) { return { value: v, enumerable: false, writable: true, configurable: true } }; global.Base64.extendString = function () { Object.defineProperty(String.prototype, "fromBase64", noEnum(function () { return decode(this) })); Object.defineProperty(String.prototype, "toBase64", noEnum(function (urisafe) { return encode(this, urisafe) })); Object.defineProperty(String.prototype, "toBase64URI", noEnum(function () { return encode(this, true) })) } } if (global["Meteor"]) { Base64 = global.Base64 } })(this) }, { buffer: 5 }], 10: [function (require, module, exports) { var process = module.exports = {}; var cachedSetTimeout; var cachedClearTimeout; function defaultSetTimout() { throw new Error("setTimeout has not been defined") } function defaultClearTimeout() { throw new Error("clearTimeout has not been defined") } (function () { try { if (typeof setTimeout === "function") { cachedSetTimeout = setTimeout } else { cachedSetTimeout = defaultSetTimout } } catch (e) { cachedSetTimeout = defaultSetTimout } try { if (typeof clearTimeout === "function") { cachedClearTimeout = clearTimeout } else { cachedClearTimeout = defaultClearTimeout } } catch (e) { cachedClearTimeout = defaultClearTimeout } })(); function runTimeout(fun) { if (cachedSetTimeout === setTimeout) { return setTimeout(fun, 0) } if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) { cachedSetTimeout = setTimeout; return setTimeout(fun, 0) } try { return cachedSetTimeout(fun, 0) } catch (e) { try { return cachedSetTimeout.call(null, fun, 0) } catch (e) { return cachedSetTimeout.call(this, fun, 0) } } } function runClearTimeout(marker) { if (cachedClearTimeout === clearTimeout) { return clearTimeout(marker) } if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) { cachedClearTimeout = clearTimeout; return clearTimeout(marker) } try { return cachedClearTimeout(marker) } catch (e) { try { return cachedClearTimeout.call(null, marker) } catch (e) { return cachedClearTimeout.call(this, marker) } } } var queue = []; var draining = false; var currentQueue; var queueIndex = -1; function cleanUpNextTick() { if (!draining || !currentQueue) { return } draining = false; if (currentQueue.length) { queue = currentQueue.concat(queue) } else { queueIndex = -1 } if (queue.length) { drainQueue() } } function drainQueue() { if (draining) { return } var timeout = runTimeout(cleanUpNextTick); draining = true; var len = queue.length; while (len) { currentQueue = queue; queue = []; while (++queueIndex < len) { if (currentQueue) { currentQueue[queueIndex].run() } } queueIndex = -1; len = queue.length } currentQueue = null; draining = false; runClearTimeout(timeout) } process.nextTick = function (fun) { var args = new Array(arguments.length - 1); if (arguments.length > 1) { for (var i = 1; i < arguments.length; i++) { args[i - 1] = arguments[i] } } queue.push(new Item(fun, args)); if (queue.length === 1 && !draining) { runTimeout(drainQueue) } }; function Item(fun, array) { this.fun = fun; this.array = array } Item.prototype.run = function () { this.fun.apply(null, this.array) }; process.title = "browser"; process.browser = true; process.env = {}; process.argv = []; process.version = ""; process.versions = {}; function noop() { } process.on = noop; process.addListener = noop; process.once = noop; process.off = noop; process.removeListener = noop; process.removeAllListeners = noop; process.emit = noop; process.prependListener = noop; process.prependOnceListener = noop; process.listeners = function (name) { return [] }; process.binding = function (name) { throw new Error("process.binding is not supported") }; process.cwd = function () { return "/" }; process.chdir = function (dir) { throw new Error("process.chdir is not supported") }; process.umask = function () { return 0 } }, {}] }, {}, [2]);
